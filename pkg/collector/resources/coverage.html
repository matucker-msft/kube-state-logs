
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>resources: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/certificatesigningrequest.go (86.4%)</option>
				
				<option value="file1">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/clusterrole.go (85.0%)</option>
				
				<option value="file2">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/clusterrolebinding.go (85.7%)</option>
				
				<option value="file3">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/configmap.go (100.0%)</option>
				
				<option value="file4">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/container.go (87.8%)</option>
				
				<option value="file5">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/crd.go (96.6%)</option>
				
				<option value="file6">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/cronjob.go (96.9%)</option>
				
				<option value="file7">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/daemonset.go (94.7%)</option>
				
				<option value="file8">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/deployment.go (97.4%)</option>
				
				<option value="file9">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/endpoints.go (100.0%)</option>
				
				<option value="file10">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/horizontalpodautoscaler.go (97.5%)</option>
				
				<option value="file11">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/ingress.go (100.0%)</option>
				
				<option value="file12">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/ingressclass.go (100.0%)</option>
				
				<option value="file13">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/job.go (90.6%)</option>
				
				<option value="file14">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/lease.go (97.0%)</option>
				
				<option value="file15">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/limitrange.go (100.0%)</option>
				
				<option value="file16">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/mutatingwebhookconfiguration.go (92.5%)</option>
				
				<option value="file17">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/namespace.go (100.0%)</option>
				
				<option value="file18">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/networkpolicy.go (100.0%)</option>
				
				<option value="file19">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/node.go (95.6%)</option>
				
				<option value="file20">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/persistentvolume.go (64.9%)</option>
				
				<option value="file21">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/persistentvolumeclaim.go (100.0%)</option>
				
				<option value="file22">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/pod.go (86.3%)</option>
				
				<option value="file23">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/poddisruptionbudget.go (96.6%)</option>
				
				<option value="file24">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/priorityclass.go (100.0%)</option>
				
				<option value="file25">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/replicaset.go (82.9%)</option>
				
				<option value="file26">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/replicationcontroller.go (100.0%)</option>
				
				<option value="file27">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/resourcequota.go (100.0%)</option>
				
				<option value="file28">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/role.go (81.8%)</option>
				
				<option value="file29">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/rolebinding.go (82.6%)</option>
				
				<option value="file30">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/runtimeclass.go (93.8%)</option>
				
				<option value="file31">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/secret.go (100.0%)</option>
				
				<option value="file32">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/service.go (81.7%)</option>
				
				<option value="file33">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/serviceaccount.go (100.0%)</option>
				
				<option value="file34">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/statefulset.go (96.2%)</option>
				
				<option value="file35">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/storageclass.go (100.0%)</option>
				
				<option value="file36">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/validatingadmissionpolicy.go (88.5%)</option>
				
				<option value="file37">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/validatingadmissionpolicybinding.go (87.5%)</option>
				
				<option value="file38">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/validatingwebhookconfiguration.go (97.5%)</option>
				
				<option value="file39">github.com/matucker-msft/kube-state-logs/pkg/collector/resources/volumeattachment.go (87.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package resources

import (
        "context"
        "time"

        certificatesv1 "k8s.io/api/certificates/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// CertificateSigningRequestHandler handles collection of certificatesigningrequest metrics
type CertificateSigningRequestHandler struct {
        utils.BaseHandler
}

// NewCertificateSigningRequestHandler creates a new CertificateSigningRequestHandler
func NewCertificateSigningRequestHandler(client kubernetes.Interface) *CertificateSigningRequestHandler <span class="cov8" title="1">{
        return &amp;CertificateSigningRequestHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the certificatesigningrequest informer
func (h *CertificateSigningRequestHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov0" title="0">{
        // Create certificatesigningrequest informer
        informer := factory.Certificates().V1().CertificateSigningRequests().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers certificatesigningrequest metrics from the cluster (uses cache)
func (h *CertificateSigningRequestHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all certificatesigningrequests from the cache
        csrList := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range csrList </span><span class="cov8" title="1">{
                csr, ok := obj.(*certificatesv1.CertificateSigningRequest)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(csr)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a certificatesigningrequest
func (h *CertificateSigningRequestHandler) createLogEntry(csr *certificatesv1.CertificateSigningRequest) types.LogEntry <span class="cov8" title="1">{
        // Convert usages to strings
        var usages []string
        for _, usage := range csr.Spec.Usages </span><span class="cov8" title="1">{
                usages = append(usages, string(usage))
        }</span>

        // Get status
        <span class="cov8" title="1">status := ""
        if len(csr.Status.Conditions) &gt; 0 </span><span class="cov8" title="1">{
                status = string(csr.Status.Conditions[0].Type)
        }</span>

        <span class="cov8" title="1">createdByKind, createdByName := utils.GetOwnerReferenceInfo(csr)

        // Create data structure
        data := types.CertificateSigningRequestData{
                CreatedTimestamp:  utils.ExtractCreationTimestamp(csr),
                Labels:            utils.ExtractLabels(csr),
                Annotations:       utils.ExtractAnnotations(csr),
                Status:            status,
                SignerName:        csr.Spec.SignerName,
                ExpirationSeconds: csr.Spec.ExpirationSeconds,
                Usages:            usages,
                CreatedByKind:     createdByKind,
                CreatedByName:     createdByName,
        }

        return utils.CreateLogEntry("certificatesigningrequest", utils.ExtractName(csr), utils.ExtractNamespace(csr), data)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package resources

import (
        "context"
        "time"

        rbacv1 "k8s.io/api/rbac/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// ClusterRoleHandler handles collection of clusterrole metrics
type ClusterRoleHandler struct {
        utils.BaseHandler
}

// NewClusterRoleHandler creates a new ClusterRoleHandler
func NewClusterRoleHandler(client kubernetes.Interface) *ClusterRoleHandler <span class="cov8" title="1">{
        return &amp;ClusterRoleHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the clusterrole informer
func (h *ClusterRoleHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov0" title="0">{
        // Create clusterrole informer
        informer := factory.Rbac().V1().ClusterRoles().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers clusterrole metrics from the cluster (uses cache)
func (h *ClusterRoleHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all clusterroles from the cache
        crList := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range crList </span><span class="cov8" title="1">{
                cr, ok := obj.(*rbacv1.ClusterRole)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(cr)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a clusterrole
func (h *ClusterRoleHandler) createLogEntry(cr *rbacv1.ClusterRole) types.LogEntry <span class="cov8" title="1">{
        // Convert rules
        // See: https://kubernetes.io/docs/reference/access-authn-authz/rbac/#role-and-clusterrole
        var rules []types.PolicyRule
        for _, rule := range cr.Rules </span><span class="cov8" title="1">{
                policyRule := types.PolicyRule{
                        APIGroups:     rule.APIGroups,
                        Resources:     rule.Resources,
                        ResourceNames: rule.ResourceNames,
                        Verbs:         rule.Verbs,
                }
                rules = append(rules, policyRule)
        }</span>

        <span class="cov8" title="1">createdByKind, createdByName := utils.GetOwnerReferenceInfo(cr)

        // Create data structure
        data := types.ClusterRoleData{
                CreatedTimestamp: utils.ExtractCreationTimestamp(cr),
                Labels:           utils.ExtractLabels(cr),
                Annotations:      utils.ExtractAnnotations(cr),
                Rules:            rules,
                CreatedByKind:    createdByKind,
                CreatedByName:    createdByName,
        }

        return utils.CreateLogEntry("clusterrole", utils.ExtractName(cr), utils.ExtractNamespace(cr), data)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package resources

import (
        "context"
        "time"

        rbacv1 "k8s.io/api/rbac/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// ClusterRoleBindingHandler handles collection of clusterrolebinding metrics
type ClusterRoleBindingHandler struct {
        utils.BaseHandler
}

// NewClusterRoleBindingHandler creates a new ClusterRoleBindingHandler
func NewClusterRoleBindingHandler(client kubernetes.Interface) *ClusterRoleBindingHandler <span class="cov8" title="1">{
        return &amp;ClusterRoleBindingHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the clusterrolebinding informer
func (h *ClusterRoleBindingHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov0" title="0">{
        // Create clusterrolebinding informer
        informer := factory.Rbac().V1().ClusterRoleBindings().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers clusterrolebinding metrics from the cluster (uses cache)
func (h *ClusterRoleBindingHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all clusterrolebindings from the cache
        crbList := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range crbList </span><span class="cov8" title="1">{
                crb, ok := obj.(*rbacv1.ClusterRoleBinding)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(crb)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a clusterrolebinding
func (h *ClusterRoleBindingHandler) createLogEntry(crb *rbacv1.ClusterRoleBinding) types.LogEntry <span class="cov8" title="1">{
        // Convert role ref
        roleRef := types.RoleRef{
                APIGroup: crb.RoleRef.APIGroup,
                Kind:     crb.RoleRef.Kind,
                Name:     crb.RoleRef.Name,
        }

        // Convert subjects
        var subjects []types.Subject
        for _, subject := range crb.Subjects </span><span class="cov8" title="1">{
                subj := types.Subject{
                        Kind:      subject.Kind,
                        Name:      subject.Name,
                        Namespace: subject.Namespace,
                        APIGroup:  subject.APIGroup,
                }
                subjects = append(subjects, subj)
        }</span>

        <span class="cov8" title="1">createdByKind, createdByName := utils.GetOwnerReferenceInfo(crb)

        // Create data structure
        data := types.ClusterRoleBindingData{
                CreatedTimestamp: utils.ExtractCreationTimestamp(crb),
                Labels:           utils.ExtractLabels(crb),
                Annotations:      utils.ExtractAnnotations(crb),
                RoleRef:          roleRef,
                Subjects:         subjects,
                CreatedByKind:    createdByKind,
                CreatedByName:    createdByName,
        }

        return utils.CreateLogEntry("clusterrolebinding", utils.ExtractName(crb), utils.ExtractNamespace(crb), data)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package resources

import (
        "context"
        "time"

        corev1 "k8s.io/api/core/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// ConfigMapHandler handles collection of configmap metrics
type ConfigMapHandler struct {
        utils.BaseHandler
}

// NewConfigMapHandler creates a new ConfigMapHandler
func NewConfigMapHandler(client kubernetes.Interface) *ConfigMapHandler <span class="cov8" title="1">{
        return &amp;ConfigMapHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the configmap informer
func (h *ConfigMapHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create configmap informer
        informer := factory.Core().V1().ConfigMaps().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers configmap metrics from the cluster (uses cache)
func (h *ConfigMapHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all configmaps from the cache
        configmaps := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range configmaps </span><span class="cov8" title="1">{
                configmap, ok := obj.(*corev1.ConfigMap)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if !utils.ShouldIncludeNamespace(namespaces, configmap.Namespace) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(configmap)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a configmap
func (h *ConfigMapHandler) createLogEntry(configmap *corev1.ConfigMap) types.LogEntry <span class="cov8" title="1">{
        createdByKind, createdByName := utils.GetOwnerReferenceInfo(configmap)

        var dataKeys []string
        for key := range configmap.Data </span><span class="cov8" title="1">{
                dataKeys = append(dataKeys, key)
        }</span>

        <span class="cov8" title="1">data := types.ConfigMapData{
                CreatedTimestamp: utils.ExtractCreationTimestamp(configmap),
                Labels:           utils.ExtractLabels(configmap),
                Annotations:      utils.ExtractAnnotations(configmap),
                DataKeys:         dataKeys,
                CreatedByKind:    createdByKind,
                CreatedByName:    createdByName,
        }

        return utils.CreateLogEntry("configmap", utils.ExtractName(configmap), utils.ExtractNamespace(configmap), data)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package resources

import (
        "context"
        "time"

        corev1 "k8s.io/api/core/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// ContainerHandler handles collection of container metrics
type ContainerHandler struct {
        utils.BaseHandler
}

// NewContainerHandler creates a new ContainerHandler
func NewContainerHandler(client kubernetes.Interface) *ContainerHandler <span class="cov8" title="1">{
        return &amp;ContainerHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the pod informer (containers are accessed through pods)
func (h *ContainerHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create pod informer (containers are accessed through pods)
        informer := factory.Core().V1().Pods().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers container metrics from the cluster (uses cache)
func (h *ContainerHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all pods from the cache
        pods := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range pods </span><span class="cov8" title="1">{
                pod, ok := obj.(*corev1.Pod)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if !utils.ShouldIncludeNamespace(namespaces, pod.Namespace) </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Create separate log entries for each container
                <span class="cov8" title="1">containerEntries := h.createContainerLogEntries(pod)
                entries = append(entries, containerEntries...)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createContainerLogEntries creates LogEntry for each container in a pod
func (h *ContainerHandler) createContainerLogEntries(pod *corev1.Pod) []types.LogEntry <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Process all containers (including init containers)
        for _, container := range pod.Spec.Containers </span><span class="cov8" title="1">{
                entry := h.createContainerLogEntry(pod, &amp;container, false)
                entries = append(entries, entry)
        }</span>

        <span class="cov8" title="1">for _, container := range pod.Spec.InitContainers </span><span class="cov8" title="1">{
                entry := h.createContainerLogEntry(pod, &amp;container, true)
                entries = append(entries, entry)
        }</span>

        <span class="cov8" title="1">return entries</span>
}

// createContainerLogEntry creates a LogEntry for a specific container
func (h *ContainerHandler) createContainerLogEntry(pod *corev1.Pod, containerSpec *corev1.Container, isInit bool) types.LogEntry <span class="cov8" title="1">{
        // Find container status
        var containerStatus *corev1.ContainerStatus
        statuses := pod.Status.ContainerStatuses
        if isInit </span><span class="cov8" title="1">{
                statuses = pod.Status.InitContainerStatuses
        }</span>

        <span class="cov8" title="1">for _, status := range statuses </span><span class="cov8" title="1">{
                if status.Name == containerSpec.Name </span><span class="cov8" title="1">{
                        containerStatus = &amp;status
                        break</span>
                }
        }

        // Determine container state
        <span class="cov8" title="1">state := "unknown"
        stateRunning := false
        stateWaiting := false
        stateTerminated := false
        var waitingReason, waitingMessage string
        var startedAt *time.Time
        var exitCode int32
        var reason, message string
        var finishedAt, startedAtTerm *time.Time

        // Last terminated state info
        var lastTerminatedReason string
        var lastTerminatedExitCode int32
        var lastTerminatedTimestamp *time.Time

        if containerStatus != nil </span><span class="cov8" title="1">{
                if containerStatus.State.Running != nil </span><span class="cov8" title="1">{
                        state = "running"
                        stateRunning = true
                        if !containerStatus.State.Running.StartedAt.IsZero() </span><span class="cov8" title="1">{
                                startedAt = &amp;containerStatus.State.Running.StartedAt.Time
                        }</span>
                } else<span class="cov8" title="1"> if containerStatus.State.Waiting != nil </span><span class="cov0" title="0">{
                        state = "waiting"
                        stateWaiting = true
                        waitingReason = string(containerStatus.State.Waiting.Reason)
                        waitingMessage = containerStatus.State.Waiting.Message
                }</span> else<span class="cov8" title="1"> if containerStatus.State.Terminated != nil </span><span class="cov8" title="1">{
                        state = "terminated"
                        stateTerminated = true
                        exitCode = containerStatus.State.Terminated.ExitCode
                        reason = string(containerStatus.State.Terminated.Reason)
                        message = containerStatus.State.Terminated.Message
                        if !containerStatus.State.Terminated.FinishedAt.IsZero() </span><span class="cov8" title="1">{
                                finishedAt = &amp;containerStatus.State.Terminated.FinishedAt.Time
                        }</span>
                        <span class="cov8" title="1">if !containerStatus.State.Terminated.StartedAt.IsZero() </span><span class="cov8" title="1">{
                                startedAtTerm = &amp;containerStatus.State.Terminated.StartedAt.Time
                        }</span>
                }

                // Get last terminated state
                <span class="cov8" title="1">if containerStatus.LastTerminationState.Terminated != nil </span><span class="cov0" title="0">{
                        lastTerminatedReason = string(containerStatus.LastTerminationState.Terminated.Reason)
                        lastTerminatedExitCode = containerStatus.LastTerminationState.Terminated.ExitCode
                        if !containerStatus.LastTerminationState.Terminated.FinishedAt.IsZero() </span><span class="cov0" title="0">{
                                lastTerminatedTimestamp = &amp;containerStatus.LastTerminationState.Terminated.FinishedAt.Time
                        }</span>
                }
        }

        // Extract resource requests and limits
        <span class="cov8" title="1">resourceRequests := utils.ExtractResourceMap(containerSpec.Resources.Requests)
        resourceLimits := utils.ExtractResourceMap(containerSpec.Resources.Limits)

        imageID := ""
        if containerStatus != nil </span><span class="cov8" title="1">{
                imageID = containerStatus.ImageID
        }</span>

        // Get state started time (when container first started)
        <span class="cov8" title="1">var stateStarted *time.Time
        if containerStatus != nil &amp;&amp; containerStatus.State.Running != nil &amp;&amp; !containerStatus.State.Running.StartedAt.IsZero() </span><span class="cov8" title="1">{
                stateStarted = &amp;containerStatus.State.Running.StartedAt.Time
        }</span>

        <span class="cov8" title="1">data := types.ContainerData{
                Name:    containerSpec.Name,
                Image:   containerSpec.Image,
                ImageID: imageID,
                PodName: pod.Name,
                Ready:   containerStatus != nil &amp;&amp; containerStatus.Ready,
                RestartCount: func() int32 </span><span class="cov8" title="1">{
                        if containerStatus != nil </span><span class="cov8" title="1">{
                                return containerStatus.RestartCount
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                }(),
                State:                   state,
                StateRunning:            stateRunning,
                StateWaiting:            stateWaiting,
                StateTerminated:         stateTerminated,
                WaitingReason:           waitingReason,
                WaitingMessage:          waitingMessage,
                StartedAt:               startedAt,
                ExitCode:                exitCode,
                Reason:                  reason,
                Message:                 message,
                FinishedAt:              finishedAt,
                StartedAtTerm:           startedAtTerm,
                ResourceRequests:        resourceRequests,
                ResourceLimits:          resourceLimits,
                LastTerminatedReason:    lastTerminatedReason,
                LastTerminatedExitCode:  lastTerminatedExitCode,
                LastTerminatedTimestamp: lastTerminatedTimestamp,
                StateStarted:            stateStarted,
        }

        <span class="cov8" title="1">return utils.CreateLogEntry("container", utils.ExtractName(pod)+"-"+containerSpec.Name, utils.ExtractNamespace(pod), data)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package resources

import (
        "context"
        "time"

        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/client-go/dynamic"
        "k8s.io/client-go/dynamic/dynamicinformer"
        "k8s.io/client-go/tools/cache"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// CRDHandler handles collection of generic CRD metrics
type CRDHandler struct {
        client       dynamic.Interface
        informer     cache.SharedIndexInformer
        logger       interfaces.Logger
        gvr          schema.GroupVersionResource
        resourceName string
        customFields []string // JSONPath-like field paths to extract
}

// NewCRDHandler creates a new CRDHandler for a specific CRD
func NewCRDHandler(client dynamic.Interface, gvr schema.GroupVersionResource, resourceName string, customFields []string) *CRDHandler <span class="cov8" title="1">{
        return &amp;CRDHandler{
                client:       client,
                gvr:          gvr,
                resourceName: resourceName,
                customFields: customFields,
        }
}</span>

// SetupInformer sets up the CRD informer
func (h *CRDHandler) SetupInformer(factory dynamicinformer.DynamicSharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        h.logger = logger

        // Create dynamic informer for the CRD
        h.informer = factory.ForResource(h.gvr).Informer()

        return nil
}</span>

// Collect gathers CRD metrics from the cluster (uses cache)
func (h *CRDHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all CRD resources from the cache
        crdList := utils.SafeGetStoreList(h.informer)

        for _, obj := range crdList </span><span class="cov8" title="1">{
                unstructuredObj, ok := obj.(*unstructured.Unstructured)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if !utils.ShouldIncludeNamespace(namespaces, unstructuredObj.GetNamespace()) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(unstructuredObj)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a CRD resource
func (h *CRDHandler) createLogEntry(obj *unstructured.Unstructured) types.LogEntry <span class="cov8" title="1">{
        // Extract spec and status
        spec := make(map[string]any)
        if specObj, exists, _ := unstructured.NestedMap(obj.Object, "spec"); exists </span><span class="cov8" title="1">{
                spec = specObj
        }</span>

        <span class="cov8" title="1">status := make(map[string]any)
        if statusObj, exists, _ := unstructured.NestedMap(obj.Object, "status"); exists </span><span class="cov8" title="1">{
                status = statusObj
        }</span>

        // Extract custom fields based on JSONPath-like paths
        <span class="cov8" title="1">customFields := make(map[string]any)
        for _, fieldPath := range h.customFields </span><span class="cov8" title="1">{
                if value := h.extractField(obj.Object, fieldPath); value != nil </span><span class="cov8" title="1">{
                        customFields[fieldPath] = value
                }</span>
        }

        <span class="cov8" title="1">createdByKind, createdByName := utils.GetOwnerReferenceInfo(obj)

        // Create data structure
        data := types.CRDData{
                CreatedTimestamp: utils.ExtractCreationTimestamp(obj),
                Labels:           utils.ExtractLabels(obj),
                Annotations:      utils.ExtractAnnotations(obj),
                APIVersion:       obj.GetAPIVersion(),
                Kind:             obj.GetKind(),
                Spec:             spec,
                Status:           status,
                CustomFields:     customFields,
                CreatedByKind:    createdByKind,
                CreatedByName:    createdByName,
        }

        return utils.CreateLogEntry("crd", utils.ExtractName(obj), utils.ExtractNamespace(obj), data)</span>
}

// extractField extracts a field from an object using a dot-separated path
func (h *CRDHandler) extractField(obj map[string]any, path string) any <span class="cov8" title="1">{
        return utils.ExtractField(obj, path)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package resources

import (
        "context"
        "time"

        batchv1 "k8s.io/api/batch/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// CronJobHandler handles collection of cronjob metrics
type CronJobHandler struct {
        utils.BaseHandler
}

// NewCronJobHandler creates a new CronJobHandler
func NewCronJobHandler(client kubernetes.Interface) *CronJobHandler <span class="cov8" title="1">{
        return &amp;CronJobHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the cronjob informer
func (h *CronJobHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create cronjob informer
        informer := factory.Batch().V1().CronJobs().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers cronjob metrics from the cluster (uses cache)
func (h *CronJobHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all cronjobs from the cache
        cronjobs := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range cronjobs </span><span class="cov8" title="1">{
                cronjob, ok := obj.(*batchv1.CronJob)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if !utils.ShouldIncludeNamespace(namespaces, cronjob.Namespace) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(cronjob)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a cronjob
func (h *CronJobHandler) createLogEntry(cronjob *batchv1.CronJob) types.LogEntry <span class="cov8" title="1">{
        concurrencyPolicy := string(cronjob.Spec.ConcurrencyPolicy)
        createdByKind, createdByName := utils.GetOwnerReferenceInfo(cronjob)

        var suspend *bool
        if cronjob.Spec.Suspend != nil </span><span class="cov8" title="1">{
                suspend = cronjob.Spec.Suspend
        }</span>

        <span class="cov8" title="1">var successfulJobsHistoryLimit *int32
        var failedJobsHistoryLimit *int32
        if cronjob.Spec.SuccessfulJobsHistoryLimit != nil </span><span class="cov8" title="1">{
                successfulJobsHistoryLimit = cronjob.Spec.SuccessfulJobsHistoryLimit
        }</span>
        <span class="cov8" title="1">if cronjob.Spec.FailedJobsHistoryLimit != nil </span><span class="cov8" title="1">{
                failedJobsHistoryLimit = cronjob.Spec.FailedJobsHistoryLimit
        }</span>

        <span class="cov8" title="1">var lastScheduleTime *time.Time
        if cronjob.Status.LastScheduleTime != nil </span><span class="cov8" title="1">{
                lastScheduleTime = &amp;cronjob.Status.LastScheduleTime.Time
        }</span>

        <span class="cov8" title="1">conditionActive := len(cronjob.Status.Active) &gt; 0

        data := types.CronJobData{
                CreatedTimestamp:           utils.ExtractCreationTimestamp(cronjob),
                Labels:                     utils.ExtractLabels(cronjob),
                Annotations:                utils.ExtractAnnotations(cronjob),
                Schedule:                   cronjob.Spec.Schedule,
                ConcurrencyPolicy:          concurrencyPolicy,
                Suspend:                    suspend,
                SuccessfulJobsHistoryLimit: successfulJobsHistoryLimit,
                FailedJobsHistoryLimit:     failedJobsHistoryLimit,
                ActiveJobsCount:            int32(len(cronjob.Status.Active)),
                LastScheduleTime:           lastScheduleTime,
                NextScheduleTime:           nil,
                ConditionActive:            conditionActive,
                CreatedByKind:              createdByKind,
                CreatedByName:              createdByName,
        }

        return utils.CreateLogEntry("cronjob", utils.ExtractName(cronjob), utils.ExtractNamespace(cronjob), data)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package resources

import (
        "context"
        "time"

        appsv1 "k8s.io/api/apps/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// DaemonSetHandler handles collection of daemonset metrics
type DaemonSetHandler struct {
        utils.BaseHandler
}

// NewDaemonSetHandler creates a new DaemonSetHandler
func NewDaemonSetHandler(client kubernetes.Interface) *DaemonSetHandler <span class="cov8" title="1">{
        return &amp;DaemonSetHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the daemonset informer
func (h *DaemonSetHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create daemonset informer
        informer := factory.Apps().V1().DaemonSets().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers daemonset metrics from the cluster (uses cache)
func (h *DaemonSetHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all daemonsets from the cache
        daemonsets := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range daemonsets </span><span class="cov8" title="1">{
                ds, ok := obj.(*appsv1.DaemonSet)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if !utils.ShouldIncludeNamespace(namespaces, ds.Namespace) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(ds)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a daemonset
func (h *DaemonSetHandler) createLogEntry(ds *appsv1.DaemonSet) types.LogEntry <span class="cov8" title="1">{
        createdByKind, createdByName := utils.GetOwnerReferenceInfo(ds)

        // Get update strategy
        updateStrategy := string(ds.Spec.UpdateStrategy.Type)

        data := types.DaemonSetData{
                CreatedTimestamp:        utils.ExtractCreationTimestamp(ds),
                Labels:                  utils.ExtractLabels(ds),
                Annotations:             utils.ExtractAnnotations(ds),
                DesiredNumberScheduled:  ds.Status.DesiredNumberScheduled,
                CurrentNumberScheduled:  ds.Status.CurrentNumberScheduled,
                NumberReady:             ds.Status.NumberReady,
                NumberAvailable:         ds.Status.NumberAvailable,
                NumberUnavailable:       ds.Status.NumberUnavailable,
                NumberMisscheduled:      ds.Status.NumberMisscheduled,
                UpdatedNumberScheduled:  ds.Status.UpdatedNumberScheduled,
                ObservedGeneration:      ds.Status.ObservedGeneration,
                ConditionAvailable:      utils.GetConditionStatusGeneric(ds.Status.Conditions, "DaemonSetAvailable"),
                ConditionProgressing:    utils.GetConditionStatusGeneric(ds.Status.Conditions, "DaemonSetProgressing"),
                ConditionReplicaFailure: utils.GetConditionStatusGeneric(ds.Status.Conditions, "DaemonSetReplicaFailure"),
                CreatedByKind:           createdByKind,
                CreatedByName:           createdByName,
                UpdateStrategy:          updateStrategy,
        }

        return utils.CreateLogEntry("daemonset", utils.ExtractName(ds), utils.ExtractNamespace(ds), data)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package resources

import (
        "context"
        "time"

        appsv1 "k8s.io/api/apps/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// DeploymentHandler handles collection of deployment metrics
type DeploymentHandler struct {
        utils.BaseHandler
}

// NewDeploymentHandler creates a new DeploymentHandler
func NewDeploymentHandler(client kubernetes.Interface) *DeploymentHandler <span class="cov8" title="1">{
        return &amp;DeploymentHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the deployment informer
func (h *DeploymentHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create deployment informer
        informer := factory.Apps().V1().Deployments().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers deployment metrics from the cluster (uses cache)
func (h *DeploymentHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all deployments from the cache
        deployments := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range deployments </span><span class="cov8" title="1">{
                deployment, ok := obj.(*appsv1.Deployment)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if !utils.ShouldIncludeNamespace(namespaces, deployment.Namespace) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(deployment)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a deployment
func (h *DeploymentHandler) createLogEntry(deployment *appsv1.Deployment) types.LogEntry <span class="cov8" title="1">{
        // Get strategy info
        strategyType := string(deployment.Spec.Strategy.Type)
        strategyRollingUpdateMaxSurge := int32(0)
        strategyRollingUpdateMaxUnavailable := int32(0)

        if deployment.Spec.Strategy.RollingUpdate != nil </span><span class="cov8" title="1">{
                if deployment.Spec.Strategy.RollingUpdate.MaxSurge != nil </span><span class="cov8" title="1">{
                        strategyRollingUpdateMaxSurge = deployment.Spec.Strategy.RollingUpdate.MaxSurge.IntVal
                }</span>
                <span class="cov8" title="1">if deployment.Spec.Strategy.RollingUpdate.MaxUnavailable != nil </span><span class="cov8" title="1">{
                        strategyRollingUpdateMaxUnavailable = deployment.Spec.Strategy.RollingUpdate.MaxUnavailable.IntVal
                }</span>
        }

        // Get desired replicas with nil check
        <span class="cov8" title="1">desiredReplicas := int32(1) // Default value per Kubernetes API
        if deployment.Spec.Replicas != nil </span><span class="cov8" title="1">{
                desiredReplicas = *deployment.Spec.Replicas
        }</span>

        <span class="cov8" title="1">createdByKind, createdByName := utils.GetOwnerReferenceInfo(deployment)

        // Get status fields with nil checks
        currentReplicas := deployment.Status.Replicas
        readyReplicas := deployment.Status.ReadyReplicas
        availableReplicas := deployment.Status.AvailableReplicas
        unavailableReplicas := deployment.Status.UnavailableReplicas
        updatedReplicas := deployment.Status.UpdatedReplicas
        observedGeneration := deployment.Status.ObservedGeneration

        data := types.DeploymentData{
                CreatedTimestamp:                    utils.ExtractCreationTimestamp(deployment),
                Labels:                              utils.ExtractLabels(deployment),
                Annotations:                         utils.ExtractAnnotations(deployment),
                DesiredReplicas:                     desiredReplicas,
                CurrentReplicas:                     currentReplicas,
                ReadyReplicas:                       readyReplicas,
                AvailableReplicas:                   availableReplicas,
                UnavailableReplicas:                 unavailableReplicas,
                UpdatedReplicas:                     updatedReplicas,
                ObservedGeneration:                  observedGeneration,
                ReplicasDesired:                     desiredReplicas,
                ReplicasAvailable:                   availableReplicas,
                ReplicasUnavailable:                 unavailableReplicas,
                ReplicasUpdated:                     updatedReplicas,
                StrategyType:                        strategyType,
                StrategyRollingUpdateMaxSurge:       strategyRollingUpdateMaxSurge,
                StrategyRollingUpdateMaxUnavailable: strategyRollingUpdateMaxUnavailable,
                ConditionAvailable:                  h.getConditionStatus(deployment.Status.Conditions, "Available"),
                ConditionProgressing:                h.getConditionStatus(deployment.Status.Conditions, "Progressing"),
                ConditionReplicaFailure:             h.getConditionStatus(deployment.Status.Conditions, "ReplicaFailure"),
                CreatedByKind:                       createdByKind,
                CreatedByName:                       createdByName,
                Paused:                              deployment.Spec.Paused,
                MetadataGeneration:                  utils.ExtractGeneration(deployment),
        }

        return utils.CreateLogEntry("deployment", utils.ExtractName(deployment), utils.ExtractNamespace(deployment), data)</span>
}

// getConditionStatus checks if a condition is true
func (h *DeploymentHandler) getConditionStatus(conditions []appsv1.DeploymentCondition, conditionType string) bool <span class="cov8" title="1">{
        for _, condition := range conditions </span><span class="cov8" title="1">{
                if condition.Type == appsv1.DeploymentConditionType(conditionType) </span><span class="cov8" title="1">{
                        return condition.Status == "True"
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package resources

import (
        "context"
        "time"

        corev1 "k8s.io/api/core/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// EndpointsHandler handles collection of endpoints metrics
type EndpointsHandler struct {
        utils.BaseHandler
}

// NewEndpointsHandler creates a new EndpointsHandler
func NewEndpointsHandler(client kubernetes.Interface) *EndpointsHandler <span class="cov8" title="1">{
        return &amp;EndpointsHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the endpoints informer
func (h *EndpointsHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create endpoints informer
        informer := factory.Core().V1().Endpoints().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers endpoints metrics from the cluster (uses cache)
func (h *EndpointsHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all endpoints from the cache
        endpointsList := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range endpointsList </span><span class="cov8" title="1">{
                endpoints, ok := obj.(*corev1.Endpoints)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if !utils.ShouldIncludeNamespace(namespaces, endpoints.Namespace) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(endpoints)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from endpoints
func (h *EndpointsHandler) createLogEntry(endpoints *corev1.Endpoints) types.LogEntry <span class="cov8" title="1">{
        // Extract addresses and ports from all subsets
        var addresses []types.EndpointAddressData
        var ports []types.EndpointPortData

        for _, subset := range endpoints.Subsets </span><span class="cov8" title="1">{
                // Extract addresses
                for _, address := range subset.Addresses </span><span class="cov8" title="1">{
                        targetRef := ""
                        if address.TargetRef != nil </span><span class="cov8" title="1">{
                                targetRef = address.TargetRef.Name
                        }</span>

                        <span class="cov8" title="1">nodeName := ""
                        if address.NodeName != nil </span><span class="cov8" title="1">{
                                nodeName = *address.NodeName
                        }</span>

                        <span class="cov8" title="1">addresses = append(addresses, types.EndpointAddressData{
                                IP:        address.IP,
                                Hostname:  address.Hostname,
                                NodeName:  nodeName,
                                TargetRef: targetRef,
                        })</span>
                }

                // Extract ports
                <span class="cov8" title="1">for _, port := range subset.Ports </span><span class="cov8" title="1">{
                        ports = append(ports, types.EndpointPortData{
                                Name:     port.Name,
                                Protocol: string(port.Protocol),
                                Port:     port.Port,
                        })
                }</span>
        }

        // Determine if endpoints are ready (have addresses)
        <span class="cov8" title="1">ready := len(addresses) &gt; 0

        createdByKind, createdByName := utils.GetOwnerReferenceInfo(endpoints)

        // Create data structure
        data := types.EndpointsData{
                CreatedTimestamp: utils.ExtractCreationTimestamp(endpoints),
                Labels:           utils.ExtractLabels(endpoints),
                Annotations:      utils.ExtractAnnotations(endpoints),
                Addresses:        addresses,
                Ports:            ports,
                CreatedByKind:    createdByKind,
                CreatedByName:    createdByName,
                Ready:            ready,
        }

        return utils.CreateLogEntry("endpoints", utils.ExtractName(endpoints), utils.ExtractNamespace(endpoints), data)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package resources

import (
        "context"
        "time"

        autoscalingv2 "k8s.io/api/autoscaling/v2"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// HorizontalPodAutoscalerHandler handles collection of horizontalpodautoscaler metrics
type HorizontalPodAutoscalerHandler struct {
        utils.BaseHandler
}

// NewHorizontalPodAutoscalerHandler creates a new HorizontalPodAutoscalerHandler
func NewHorizontalPodAutoscalerHandler(client kubernetes.Interface) *HorizontalPodAutoscalerHandler <span class="cov8" title="1">{
        return &amp;HorizontalPodAutoscalerHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the horizontalpodautoscaler informer
func (h *HorizontalPodAutoscalerHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create horizontalpodautoscaler informer
        informer := factory.Autoscaling().V2().HorizontalPodAutoscalers().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers horizontalpodautoscaler metrics from the cluster (uses cache)
func (h *HorizontalPodAutoscalerHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all horizontalpodautoscalers from the cache
        hpaList := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range hpaList </span><span class="cov8" title="1">{
                hpa, ok := obj.(*autoscalingv2.HorizontalPodAutoscaler)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if !utils.ShouldIncludeNamespace(namespaces, hpa.Namespace) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(hpa)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a horizontalpodautoscaler
func (h *HorizontalPodAutoscalerHandler) createLogEntry(hpa *autoscalingv2.HorizontalPodAutoscaler) types.LogEntry <span class="cov8" title="1">{
        // Extract target CPU and memory utilization
        var targetCPUUtilizationPercentage *int32
        var targetMemoryUtilizationPercentage *int32

        for _, metric := range hpa.Spec.Metrics </span><span class="cov8" title="1">{
                if metric.Type == autoscalingv2.ResourceMetricSourceType </span><span class="cov8" title="1">{
                        if metric.Resource.Name == "cpu" &amp;&amp; metric.Resource.Target.Type == autoscalingv2.UtilizationMetricType </span><span class="cov8" title="1">{
                                targetCPUUtilizationPercentage = metric.Resource.Target.AverageUtilization
                        }</span>
                        <span class="cov8" title="1">if metric.Resource.Name == "memory" &amp;&amp; metric.Resource.Target.Type == autoscalingv2.UtilizationMetricType </span><span class="cov8" title="1">{
                                targetMemoryUtilizationPercentage = metric.Resource.Target.AverageUtilization
                        }</span>
                }
        }

        // Extract current CPU and memory utilization
        <span class="cov8" title="1">var currentCPUUtilizationPercentage *int32
        var currentMemoryUtilizationPercentage *int32

        for _, metric := range hpa.Status.CurrentMetrics </span><span class="cov8" title="1">{
                if metric.Type == autoscalingv2.ResourceMetricSourceType </span><span class="cov8" title="1">{
                        if metric.Resource.Name == "cpu" </span><span class="cov8" title="1">{
                                currentCPUUtilizationPercentage = metric.Resource.Current.AverageUtilization
                        }</span>
                        <span class="cov8" title="1">if metric.Resource.Name == "memory" </span><span class="cov0" title="0">{
                                currentMemoryUtilizationPercentage = metric.Resource.Current.AverageUtilization
                        }</span>
                }
        }

        // Use utils for condition checks
        <span class="cov8" title="1">conditionAbleToScale := utils.GetConditionStatusGeneric(hpa.Status.Conditions, string(autoscalingv2.AbleToScale))
        conditionScalingActive := utils.GetConditionStatusGeneric(hpa.Status.Conditions, string(autoscalingv2.ScalingActive))
        conditionScalingLimited := utils.GetConditionStatusGeneric(hpa.Status.Conditions, string(autoscalingv2.ScalingLimited))

        // Create data structure
        // Default min replicas is 1 when spec.minReplicas is nil
        // See: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/
        minReplicas := int32(1)
        if hpa.Spec.MinReplicas != nil </span><span class="cov8" title="1">{
                minReplicas = *hpa.Spec.MinReplicas
        }</span>

        <span class="cov8" title="1">createdByKind, createdByName := utils.GetOwnerReferenceInfo(hpa)

        data := types.HorizontalPodAutoscalerData{
                CreatedTimestamp:                   utils.ExtractCreationTimestamp(hpa),
                Labels:                             utils.ExtractLabels(hpa),
                Annotations:                        utils.ExtractAnnotations(hpa),
                MinReplicas:                        &amp;minReplicas,
                MaxReplicas:                        hpa.Spec.MaxReplicas,
                TargetCPUUtilizationPercentage:     targetCPUUtilizationPercentage,
                TargetMemoryUtilizationPercentage:  targetMemoryUtilizationPercentage,
                CurrentReplicas:                    hpa.Status.CurrentReplicas,
                DesiredReplicas:                    hpa.Status.DesiredReplicas,
                CurrentCPUUtilizationPercentage:    currentCPUUtilizationPercentage,
                CurrentMemoryUtilizationPercentage: currentMemoryUtilizationPercentage,
                ConditionAbleToScale:               conditionAbleToScale,
                ConditionScalingActive:             conditionScalingActive,
                ConditionScalingLimited:            conditionScalingLimited,
                CreatedByKind:                      createdByKind,
                CreatedByName:                      createdByName,
                ScaleTargetRef:                     hpa.Spec.ScaleTargetRef.Name,
                ScaleTargetKind:                    hpa.Spec.ScaleTargetRef.Kind,
        }

        return utils.CreateLogEntry("horizontalpodautoscaler", utils.ExtractName(hpa), utils.ExtractNamespace(hpa), data)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package resources

import (
        "context"
        "strconv"
        "time"

        networkingv1 "k8s.io/api/networking/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// IngressHandler handles collection of ingress metrics
type IngressHandler struct {
        utils.BaseHandler
}

// NewIngressHandler creates a new IngressHandler
func NewIngressHandler(client kubernetes.Interface) *IngressHandler <span class="cov8" title="1">{
        return &amp;IngressHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the ingress informer
func (h *IngressHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create ingress informer
        informer := factory.Networking().V1().Ingresses().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers ingress metrics from the cluster (uses cache)
func (h *IngressHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all ingresses from the cache
        ingressList := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range ingressList </span><span class="cov8" title="1">{
                ingress, ok := obj.(*networkingv1.Ingress)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if !utils.ShouldIncludeNamespace(namespaces, ingress.Namespace) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(ingress)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from an ingress
func (h *IngressHandler) createLogEntry(ingress *networkingv1.Ingress) types.LogEntry <span class="cov8" title="1">{
        // Extract ingress class name
        var ingressClassName *string
        if ingress.Spec.IngressClassName != nil </span><span class="cov8" title="1">{
                ingressClassName = ingress.Spec.IngressClassName
        }</span>

        // Extract load balancer ingress
        <span class="cov8" title="1">var loadBalancerIngress []types.LoadBalancerIngressData
        for _, lb := range ingress.Status.LoadBalancer.Ingress </span><span class="cov8" title="1">{
                loadBalancerIngress = append(loadBalancerIngress, types.LoadBalancerIngressData{
                        IP:       lb.IP,
                        Hostname: lb.Hostname,
                })
        }</span>

        // Extract rules
        <span class="cov8" title="1">var rules []types.IngressRuleData
        for _, rule := range ingress.Spec.Rules </span><span class="cov8" title="1">{
                var paths []types.IngressPathData
                if rule.HTTP != nil </span><span class="cov8" title="1">{
                        for _, path := range rule.HTTP.Paths </span><span class="cov8" title="1">{
                                pathType := ""
                                if path.PathType != nil </span><span class="cov8" title="1">{
                                        pathType = string(*path.PathType)
                                }</span>
                                // Default path type is "ImplementationSpecific" when not specified
                                // See: https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types

                                <span class="cov8" title="1">port := ""
                                if path.Backend.Service != nil </span><span class="cov8" title="1">{
                                        port = strconv.FormatInt(int64(path.Backend.Service.Port.Number), 10)
                                }</span>

                                <span class="cov8" title="1">paths = append(paths, types.IngressPathData{
                                        Path:     path.Path,
                                        PathType: pathType,
                                        Service:  path.Backend.Service.Name,
                                        Port:     port,
                                })</span>
                        }
                }

                <span class="cov8" title="1">rules = append(rules, types.IngressRuleData{
                        Host:  rule.Host,
                        Paths: paths,
                })</span>
        }

        // Extract TLS configuration
        <span class="cov8" title="1">var tls []types.IngressTLSData
        for _, tlsConfig := range ingress.Spec.TLS </span><span class="cov8" title="1">{
                tls = append(tls, types.IngressTLSData{
                        Hosts:      tlsConfig.Hosts,
                        SecretName: tlsConfig.SecretName,
                })
        }</span>

        // Determine conditions
        <span class="cov8" title="1">conditionLoadBalancerReady := false
        // Note: Ingress doesn't have conditions in the same way as other resources
        // We'll check if load balancer ingress is available as a proxy for readiness
        conditionLoadBalancerReady = len(ingress.Status.LoadBalancer.Ingress) &gt; 0

        createdByKind, createdByName := utils.GetOwnerReferenceInfo(ingress)

        // Create data structure
        data := types.IngressData{
                CreatedTimestamp:           utils.ExtractCreationTimestamp(ingress),
                Labels:                     utils.ExtractLabels(ingress),
                Annotations:                utils.ExtractAnnotations(ingress),
                IngressClassName:           ingressClassName,
                LoadBalancerIP:             "",
                LoadBalancerIngress:        loadBalancerIngress,
                Rules:                      rules,
                TLS:                        tls,
                ConditionLoadBalancerReady: conditionLoadBalancerReady,
                CreatedByKind:              createdByKind,
                CreatedByName:              createdByName,
        }

        return utils.CreateLogEntry("ingress", utils.ExtractName(ingress), utils.ExtractNamespace(ingress), data)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package resources

import (
        "context"
        "time"

        networkingv1 "k8s.io/api/networking/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// IngressClassHandler handles collection of ingressclass metrics
type IngressClassHandler struct {
        utils.BaseHandler
}

// NewIngressClassHandler creates a new IngressClassHandler
func NewIngressClassHandler(client kubernetes.Interface) *IngressClassHandler <span class="cov8" title="1">{
        return &amp;IngressClassHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the ingressclass informer
func (h *IngressClassHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create ingressclass informer
        informer := factory.Networking().V1().IngressClasses().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers ingressclass metrics from the cluster (uses cache)
func (h *IngressClassHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all ingressclasses from the cache
        icList := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range icList </span><span class="cov8" title="1">{
                ic, ok := obj.(*networkingv1.IngressClass)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(ic)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from an ingressclass
func (h *IngressClassHandler) createLogEntry(ic *networkingv1.IngressClass) types.LogEntry <span class="cov8" title="1">{
        isDefault := false
        annotations := utils.ExtractAnnotations(ic)
        if annotations != nil </span><span class="cov8" title="1">{
                if _, exists := annotations["ingressclass.kubernetes.io/is-default-class"]; exists </span><span class="cov8" title="1">{
                        isDefault = true
                }</span>
        }

        <span class="cov8" title="1">createdByKind, createdByName := utils.GetOwnerReferenceInfo(ic)

        data := types.IngressClassData{
                CreatedTimestamp: utils.ExtractCreationTimestamp(ic),
                Labels:           utils.ExtractLabels(ic),
                Annotations:      annotations,
                Controller:       ic.Spec.Controller,
                IsDefault:        isDefault,
                CreatedByKind:    createdByKind,
                CreatedByName:    createdByName,
        }

        return utils.CreateLogEntry("ingressclass", utils.ExtractName(ic), utils.ExtractNamespace(ic), data)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package resources

import (
        "context"
        "time"

        batchv1 "k8s.io/api/batch/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// JobHandler handles collection of job metrics
type JobHandler struct {
        utils.BaseHandler
}

// NewJobHandler creates a new JobHandler
func NewJobHandler(client kubernetes.Interface) *JobHandler <span class="cov8" title="1">{
        return &amp;JobHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the job informer
func (h *JobHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create job informer
        informer := factory.Batch().V1().Jobs().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers job metrics from the cluster (uses cache)
func (h *JobHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all jobs from the cache
        jobs := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range jobs </span><span class="cov8" title="1">{
                job, ok := obj.(*batchv1.Job)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if !utils.ShouldIncludeNamespace(namespaces, job.Namespace) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(job)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a job
func (h *JobHandler) createLogEntry(job *batchv1.Job) types.LogEntry <span class="cov8" title="1">{
        // Determine job type
        jobType := "Job"
        if len(job.OwnerReferences) &gt; 0 </span><span class="cov8" title="1">{
                jobType = job.OwnerReferences[0].Kind
        }</span>

        <span class="cov8" title="1">createdByKind, createdByName := utils.GetOwnerReferenceInfo(job)

        // Get job conditions
        conditionComplete := utils.GetConditionStatusGeneric(job.Status.Conditions, string(batchv1.JobComplete))
        conditionFailed := utils.GetConditionStatusGeneric(job.Status.Conditions, string(batchv1.JobFailed))

        // Get suspend status
        var suspend *bool
        if job.Spec.Suspend != nil </span><span class="cov0" title="0">{
                suspend = job.Spec.Suspend
        }</span>

        // Get active deadline seconds
        <span class="cov8" title="1">var activeDeadlineSeconds *int64
        if job.Spec.ActiveDeadlineSeconds != nil </span><span class="cov0" title="0">{
                activeDeadlineSeconds = job.Spec.ActiveDeadlineSeconds
        }</span>

        // Get backoff limit
        <span class="cov8" title="1">backoffLimit := int32(6)
        if job.Spec.BackoffLimit != nil </span><span class="cov8" title="1">{
                backoffLimit = *job.Spec.BackoffLimit
        }</span>

        <span class="cov8" title="1">data := types.JobData{
                CreatedTimestamp:      utils.ExtractCreationTimestamp(job),
                Labels:                utils.ExtractLabels(job),
                Annotations:           utils.ExtractAnnotations(job),
                ActivePods:            job.Status.Active,
                SucceededPods:         job.Status.Succeeded,
                FailedPods:            job.Status.Failed,
                Completions:           job.Spec.Completions,
                Parallelism:           job.Spec.Parallelism,
                BackoffLimit:          backoffLimit,
                ActiveDeadlineSeconds: activeDeadlineSeconds,
                ConditionComplete:     conditionComplete,
                ConditionFailed:       conditionFailed,
                CreatedByKind:         createdByKind,
                CreatedByName:         createdByName,
                JobType:               jobType,
                Suspend:               suspend,
        }

        return utils.CreateLogEntry("job", utils.ExtractName(job), utils.ExtractNamespace(job), data)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package resources

import (
        "context"
        "time"

        coordinationv1 "k8s.io/api/coordination/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// LeaseHandler handles collection of lease metrics
type LeaseHandler struct {
        utils.BaseHandler
}

// NewLeaseHandler creates a new LeaseHandler
func NewLeaseHandler(client kubernetes.Interface) *LeaseHandler <span class="cov8" title="1">{
        return &amp;LeaseHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the lease informer
func (h *LeaseHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create lease informer
        informer := factory.Coordination().V1().Leases().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers lease metrics from the cluster (uses cache)
func (h *LeaseHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all leases from the cache
        leaseList := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range leaseList </span><span class="cov8" title="1">{
                lease, ok := obj.(*coordinationv1.Lease)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if !utils.ShouldIncludeNamespace(namespaces, lease.Namespace) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(lease)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a lease
func (h *LeaseHandler) createLogEntry(lease *coordinationv1.Lease) types.LogEntry <span class="cov8" title="1">{
        // Extract timestamps
        var renewTime *time.Time
        var acquireTime *time.Time

        if lease.Spec.RenewTime != nil </span><span class="cov8" title="1">{
                renewTime = &amp;lease.Spec.RenewTime.Time
        }</span>
        <span class="cov8" title="1">if lease.Spec.AcquireTime != nil </span><span class="cov8" title="1">{
                acquireTime = &amp;lease.Spec.AcquireTime.Time
        }</span>

        // Extract holder identity
        <span class="cov8" title="1">holderIdentity := ""
        if lease.Spec.HolderIdentity != nil </span><span class="cov8" title="1">{
                holderIdentity = *lease.Spec.HolderIdentity
        }</span>

        // Extract lease duration seconds with nil check
        <span class="cov8" title="1">leaseDurationSeconds := int32(0)
        if lease.Spec.LeaseDurationSeconds != nil </span><span class="cov8" title="1">{
                leaseDurationSeconds = *lease.Spec.LeaseDurationSeconds
        }</span>

        // Extract lease transitions with nil check
        <span class="cov8" title="1">leaseTransitions := int32(0)
        if lease.Spec.LeaseTransitions != nil </span><span class="cov8" title="1">{
                leaseTransitions = *lease.Spec.LeaseTransitions
        }</span>

        <span class="cov8" title="1">createdByKind, createdByName := utils.GetOwnerReferenceInfo(lease)

        data := types.LeaseData{
                CreatedTimestamp:     utils.ExtractCreationTimestamp(lease),
                Labels:               utils.ExtractLabels(lease),
                Annotations:          utils.ExtractAnnotations(lease),
                HolderIdentity:       holderIdentity,
                LeaseDurationSeconds: leaseDurationSeconds,
                RenewTime:            renewTime,
                AcquireTime:          acquireTime,
                LeaseTransitions:     leaseTransitions,
                CreatedByKind:        createdByKind,
                CreatedByName:        createdByName,
        }

        return utils.CreateLogEntry("lease", utils.ExtractName(lease), utils.ExtractNamespace(lease), data)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package resources

import (
        "context"
        "time"

        corev1 "k8s.io/api/core/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// LimitRangeHandler handles collection of limitrange metrics
type LimitRangeHandler struct {
        utils.BaseHandler
}

// NewLimitRangeHandler creates a new LimitRangeHandler
func NewLimitRangeHandler(client kubernetes.Interface) *LimitRangeHandler <span class="cov8" title="1">{
        return &amp;LimitRangeHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the limitrange informer
func (h *LimitRangeHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create limitrange informer
        informer := factory.Core().V1().LimitRanges().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers limitrange metrics from the cluster (uses cache)
func (h *LimitRangeHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all limitranges from the cache
        lrList := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range lrList </span><span class="cov8" title="1">{
                lr, ok := obj.(*corev1.LimitRange)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if !utils.ShouldIncludeNamespace(namespaces, lr.Namespace) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(lr)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a limitrange
func (h *LimitRangeHandler) createLogEntry(lr *corev1.LimitRange) types.LogEntry <span class="cov8" title="1">{
        // Convert limits
        var limits []types.LimitRangeItem
        for _, limit := range lr.Spec.Limits </span><span class="cov8" title="1">{
                limitItem := types.LimitRangeItem{
                        Type:                 string(limit.Type),
                        ResourceType:         "",
                        ResourceName:         "",
                        Min:                  make(map[string]string),
                        Max:                  make(map[string]string),
                        Default:              make(map[string]string),
                        DefaultRequest:       make(map[string]string),
                        MaxLimitRequestRatio: make(map[string]string),
                }

                // Extract resource type and name
                for resourceName := range limit.Min </span><span class="cov8" title="1">{
                        limitItem.ResourceType = string(resourceName)
                        limitItem.ResourceName = string(resourceName)
                        break</span>
                }

                // Convert resource maps
                <span class="cov8" title="1">for key, value := range limit.Min </span><span class="cov8" title="1">{
                        limitItem.Min[string(key)] = value.String()
                }</span>
                <span class="cov8" title="1">for key, value := range limit.Max </span><span class="cov8" title="1">{
                        limitItem.Max[string(key)] = value.String()
                }</span>
                <span class="cov8" title="1">for key, value := range limit.Default </span><span class="cov8" title="1">{
                        limitItem.Default[string(key)] = value.String()
                }</span>
                <span class="cov8" title="1">for key, value := range limit.DefaultRequest </span><span class="cov8" title="1">{
                        limitItem.DefaultRequest[string(key)] = value.String()
                }</span>
                <span class="cov8" title="1">for key, value := range limit.MaxLimitRequestRatio </span><span class="cov8" title="1">{
                        limitItem.MaxLimitRequestRatio[string(key)] = value.String()
                }</span>

                <span class="cov8" title="1">limits = append(limits, limitItem)</span>
        }

        <span class="cov8" title="1">createdByKind, createdByName := utils.GetOwnerReferenceInfo(lr)

        data := types.LimitRangeData{
                CreatedTimestamp: utils.ExtractCreationTimestamp(lr),
                Labels:           utils.ExtractLabels(lr),
                Annotations:      utils.ExtractAnnotations(lr),
                Limits:           limits,
                CreatedByKind:    createdByKind,
                CreatedByName:    createdByName,
        }

        return utils.CreateLogEntry("limitrange", utils.ExtractName(lr), utils.ExtractNamespace(lr), data)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package resources

import (
        "context"
        "time"

        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// MutatingWebhookConfigurationHandler handles collection of mutatingwebhookconfiguration metrics
type MutatingWebhookConfigurationHandler struct {
        utils.BaseHandler
}

// NewMutatingWebhookConfigurationHandler creates a new MutatingWebhookConfigurationHandler
func NewMutatingWebhookConfigurationHandler(client kubernetes.Interface) *MutatingWebhookConfigurationHandler <span class="cov8" title="1">{
        return &amp;MutatingWebhookConfigurationHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the mutatingwebhookconfiguration informer
func (h *MutatingWebhookConfigurationHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov0" title="0">{
        // Create mutatingwebhookconfiguration informer
        informer := factory.Admissionregistration().V1().MutatingWebhookConfigurations().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers mutatingwebhookconfiguration metrics from the cluster (uses cache)
func (h *MutatingWebhookConfigurationHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all mutatingwebhookconfigurations from the cache
        mwcList := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range mwcList </span><span class="cov8" title="1">{
                mwc, ok := obj.(*admissionregistrationv1.MutatingWebhookConfiguration)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(mwc)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a mutatingwebhookconfiguration
func (h *MutatingWebhookConfigurationHandler) createLogEntry(mwc *admissionregistrationv1.MutatingWebhookConfiguration) types.LogEntry <span class="cov8" title="1">{
        // Extract webhooks
        var webhooks []types.WebhookData
        for _, webhook := range mwc.Webhooks </span><span class="cov8" title="1">{
                // Extract client config
                var clientConfig types.WebhookClientConfigData
                if webhook.ClientConfig.URL != nil </span><span class="cov8" title="1">{
                        clientConfig.URL = *webhook.ClientConfig.URL
                }</span>
                <span class="cov8" title="1">if webhook.ClientConfig.Service != nil </span><span class="cov8" title="1">{
                        path := ""
                        if webhook.ClientConfig.Service.Path != nil </span><span class="cov8" title="1">{
                                path = *webhook.ClientConfig.Service.Path
                        }</span>
                        <span class="cov8" title="1">port := int32(0)
                        if webhook.ClientConfig.Service.Port != nil </span><span class="cov8" title="1">{
                                port = *webhook.ClientConfig.Service.Port
                        }</span>
                        <span class="cov8" title="1">clientConfig.Service = &amp;types.WebhookServiceData{
                                Namespace: webhook.ClientConfig.Service.Namespace,
                                Name:      webhook.ClientConfig.Service.Name,
                                Path:      path,
                                Port:      port,
                        }</span>
                }
                <span class="cov8" title="1">clientConfig.CABundle = webhook.ClientConfig.CABundle

                // Extract rules
                var rules []types.WebhookRuleData
                for _, rule := range webhook.Rules </span><span class="cov8" title="1">{
                        rules = append(rules, types.WebhookRuleData{
                                APIGroups:   rule.APIGroups,
                                APIVersions: rule.APIVersions,
                                Resources:   rule.Resources,
                                Scope:       string(*rule.Scope),
                        })
                }</span>

                // Extract selectors
                <span class="cov8" title="1">var namespaceSelector map[string]string
                if webhook.NamespaceSelector != nil </span><span class="cov8" title="1">{
                        namespaceSelector = webhook.NamespaceSelector.MatchLabels
                }</span>

                <span class="cov8" title="1">var objectSelector map[string]string
                if webhook.ObjectSelector != nil </span><span class="cov8" title="1">{
                        objectSelector = webhook.ObjectSelector.MatchLabels
                }</span>

                <span class="cov8" title="1">webhooks = append(webhooks, types.WebhookData{
                        Name:                    webhook.Name,
                        ClientConfig:            clientConfig,
                        Rules:                   rules,
                        FailurePolicy:           string(*webhook.FailurePolicy),
                        MatchPolicy:             string(*webhook.MatchPolicy),
                        NamespaceSelector:       namespaceSelector,
                        ObjectSelector:          objectSelector,
                        SideEffects:             string(*webhook.SideEffects),
                        TimeoutSeconds:          *webhook.TimeoutSeconds,
                        AdmissionReviewVersions: webhook.AdmissionReviewVersions,
                })</span>
        }

        <span class="cov8" title="1">createdByKind, createdByName := utils.GetOwnerReferenceInfo(mwc)

        // Create data structure
        data := types.MutatingWebhookConfigurationData{
                CreatedTimestamp: utils.ExtractCreationTimestamp(mwc),
                Labels:           utils.ExtractLabels(mwc),
                Annotations:      utils.ExtractAnnotations(mwc),
                Webhooks:         webhooks,
                CreatedByKind:    createdByKind,
                CreatedByName:    createdByName,
        }

        return utils.CreateLogEntry("mutatingwebhookconfiguration", utils.ExtractName(mwc), utils.ExtractNamespace(mwc), data)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package resources

import (
        "context"
        "time"

        corev1 "k8s.io/api/core/v1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// NamespaceHandler handles collection of namespace metrics
type NamespaceHandler struct {
        utils.BaseHandler
}

// NewNamespaceHandler creates a new NamespaceHandler
func NewNamespaceHandler(client kubernetes.Interface) *NamespaceHandler <span class="cov8" title="1">{
        return &amp;NamespaceHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the namespace informer
func (h *NamespaceHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create namespace informer
        informer := factory.Core().V1().Namespaces().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers namespace metrics from the cluster (uses cache)
func (h *NamespaceHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all namespaces from the cache
        namespaceList := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range namespaceList </span><span class="cov8" title="1">{
                ns, ok := obj.(*corev1.Namespace)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if !utils.ShouldIncludeNamespace(namespaces, ns.Name) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(ns)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a namespace
func (h *NamespaceHandler) createLogEntry(ns *corev1.Namespace) types.LogEntry <span class="cov8" title="1">{
        // Determine phase
        phase := string(ns.Status.Phase)

        // Determine conditions
        conditionActive := false
        conditionTerminating := false

        for _, condition := range ns.Status.Conditions </span><span class="cov8" title="1">{
                switch condition.Type </span>{
                case corev1.NamespaceConditionType("Active"):<span class="cov8" title="1">
                        conditionActive = condition.Status == corev1.ConditionTrue</span>
                case corev1.NamespaceConditionType("Terminating"):<span class="cov8" title="1">
                        conditionTerminating = condition.Status == corev1.ConditionTrue</span>
                }
        }

        <span class="cov8" title="1">createdByKind, createdByName := utils.GetOwnerReferenceInfo(ns)

        var deletionTimestamp *v1.Time
        if t := utils.ExtractDeletionTimestamp(ns); t != nil </span><span class="cov8" title="1">{
                ts := v1.NewTime(*t)
                deletionTimestamp = &amp;ts
        }</span>

        <span class="cov8" title="1">data := types.NamespaceData{
                CreatedTimestamp:     utils.ExtractCreationTimestamp(ns),
                Labels:               utils.ExtractLabels(ns),
                Annotations:          utils.ExtractAnnotations(ns),
                Phase:                phase,
                ConditionActive:      conditionActive,
                ConditionTerminating: conditionTerminating,
                CreatedByKind:        createdByKind,
                CreatedByName:        createdByName,
                DeletionTimestamp:    deletionTimestamp,
        }

        return utils.CreateLogEntry("namespace", utils.ExtractName(ns), utils.ExtractNamespace(ns), data)</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package resources

import (
        "context"
        "time"

        networkingv1 "k8s.io/api/networking/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// NetworkPolicyHandler handles collection of networkpolicy metrics
type NetworkPolicyHandler struct {
        utils.BaseHandler
}

// NewNetworkPolicyHandler creates a new NetworkPolicyHandler
func NewNetworkPolicyHandler(client kubernetes.Interface) *NetworkPolicyHandler <span class="cov8" title="1">{
        return &amp;NetworkPolicyHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the networkpolicy informer
func (h *NetworkPolicyHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create networkpolicy informer
        informer := factory.Networking().V1().NetworkPolicies().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers networkpolicy metrics from the cluster (uses cache)
func (h *NetworkPolicyHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all networkpolicies from the cache
        npList := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range npList </span><span class="cov8" title="1">{
                np, ok := obj.(*networkingv1.NetworkPolicy)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if !utils.ShouldIncludeNamespace(namespaces, np.Namespace) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(np)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a networkpolicy
func (h *NetworkPolicyHandler) createLogEntry(np *networkingv1.NetworkPolicy) types.LogEntry <span class="cov8" title="1">{
        // Get policy types
        // Default includes "Ingress" when policyTypes is not specified
        // See: https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-policies
        policyTypes := make([]string, len(np.Spec.PolicyTypes))
        for i, policyType := range np.Spec.PolicyTypes </span><span class="cov8" title="1">{
                policyTypes[i] = string(policyType)
        }</span>

        // Convert ingress rules
        <span class="cov8" title="1">var ingressRules []types.NetworkPolicyIngressRule
        for _, rule := range np.Spec.Ingress </span><span class="cov8" title="1">{
                ingressRule := types.NetworkPolicyIngressRule{
                        Ports: h.convertPorts(rule.Ports),
                        From:  h.convertPeers(rule.From),
                }
                ingressRules = append(ingressRules, ingressRule)
        }</span>

        // Convert egress rules
        <span class="cov8" title="1">var egressRules []types.NetworkPolicyEgressRule
        for _, rule := range np.Spec.Egress </span><span class="cov8" title="1">{
                egressRule := types.NetworkPolicyEgressRule{
                        Ports: h.convertPorts(rule.Ports),
                        To:    h.convertPeers(rule.To),
                }
                egressRules = append(egressRules, egressRule)
        }</span>

        <span class="cov8" title="1">createdByKind, createdByName := utils.GetOwnerReferenceInfo(np)

        // Create data structure
        data := types.NetworkPolicyData{
                CreatedTimestamp: utils.ExtractCreationTimestamp(np),
                Labels:           utils.ExtractLabels(np),
                Annotations:      utils.ExtractAnnotations(np),
                PolicyTypes:      policyTypes,
                IngressRules:     ingressRules,
                EgressRules:      egressRules,
                CreatedByKind:    createdByKind,
                CreatedByName:    createdByName,
        }

        return utils.CreateLogEntry("networkpolicy", utils.ExtractName(np), utils.ExtractNamespace(np), data)</span>
}

// convertPorts converts networkingv1.NetworkPolicyPort to types.NetworkPolicyPort
func (h *NetworkPolicyHandler) convertPorts(ports []networkingv1.NetworkPolicyPort) []types.NetworkPolicyPort <span class="cov8" title="1">{
        var result []types.NetworkPolicyPort
        for _, port := range ports </span><span class="cov8" title="1">{
                npPort := types.NetworkPolicyPort{}
                if port.Protocol != nil </span><span class="cov8" title="1">{
                        npPort.Protocol = string(*port.Protocol)
                }</span>
                <span class="cov8" title="1">if port.Port != nil </span><span class="cov8" title="1">{
                        npPort.Port = port.Port.IntVal
                }</span>
                <span class="cov8" title="1">if port.EndPort != nil </span><span class="cov8" title="1">{
                        npPort.EndPort = *port.EndPort
                }</span>
                <span class="cov8" title="1">result = append(result, npPort)</span>
        }
        <span class="cov8" title="1">return result</span>
}

// convertPeers converts networkingv1.NetworkPolicyPeer to types.NetworkPolicyPeer
func (h *NetworkPolicyHandler) convertPeers(peers []networkingv1.NetworkPolicyPeer) []types.NetworkPolicyPeer <span class="cov8" title="1">{
        var result []types.NetworkPolicyPeer
        for _, peer := range peers </span><span class="cov8" title="1">{
                npPeer := types.NetworkPolicyPeer{}

                if peer.PodSelector != nil </span><span class="cov8" title="1">{
                        npPeer.PodSelector = peer.PodSelector.MatchLabels
                }</span>
                <span class="cov8" title="1">if peer.NamespaceSelector != nil </span><span class="cov8" title="1">{
                        npPeer.NamespaceSelector = peer.NamespaceSelector.MatchLabels
                }</span>
                <span class="cov8" title="1">if peer.IPBlock != nil </span><span class="cov8" title="1">{
                        npPeer.IPBlock = map[string]any{
                                "cidr":   peer.IPBlock.CIDR,
                                "except": peer.IPBlock.Except,
                        }
                }</span>
                <span class="cov8" title="1">result = append(result, npPeer)</span>
        }
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package resources

import (
        "context"
        "strings"
        "time"

        corev1 "k8s.io/api/core/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// NodeHandler handles collection of node metrics
type NodeHandler struct {
        utils.BaseHandler
}

// NewNodeHandler creates a new NodeHandler
func NewNodeHandler(client kubernetes.Interface) *NodeHandler <span class="cov8" title="1">{
        return &amp;NodeHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the node informer
func (h *NodeHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create node informer
        informer := factory.Core().V1().Nodes().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers node metrics from the cluster (uses cache)
func (h *NodeHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all nodes from the cache
        nodes := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range nodes </span><span class="cov8" title="1">{
                node, ok := obj.(*corev1.Node)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(node)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a node
func (h *NodeHandler) createLogEntry(node *corev1.Node) types.LogEntry <span class="cov8" title="1">{
        // Get node addresses
        var internalIP, externalIP, hostname string
        if node.Status.Addresses != nil </span><span class="cov8" title="1">{
                for _, addr := range node.Status.Addresses </span><span class="cov8" title="1">{
                        switch addr.Type </span>{
                        case corev1.NodeInternalIP:<span class="cov8" title="1">
                                internalIP = addr.Address</span>
                        case corev1.NodeExternalIP:<span class="cov8" title="1">
                                externalIP = addr.Address</span>
                        case corev1.NodeHostName:<span class="cov8" title="1">
                                hostname = addr.Address</span>
                        }
                }
        }

        // Use resource utils for capacity and allocatable extraction
        <span class="cov8" title="1">capacity := utils.ExtractResourceMap(node.Status.Capacity)
        allocatable := utils.ExtractResourceMap(node.Status.Allocatable)

        // Use condition utils for node conditions
        conditions := make(map[string]bool)
        ready := utils.GetConditionStatusGeneric(node.Status.Conditions, string(corev1.NodeReady))
        if node.Status.Conditions != nil </span><span class="cov8" title="1">{
                for _, condition := range node.Status.Conditions </span><span class="cov8" title="1">{
                        conditions[string(condition.Type)] = condition.Status == corev1.ConditionTrue
                }</span>
        }

        // Determine node phase
        // See: https://kubernetes.io/docs/concepts/architecture/nodes/#node-status
        <span class="cov8" title="1">phase := "Unknown"
        if node.Status.Phase != "" </span><span class="cov8" title="1">{
                phase = string(node.Status.Phase)
        }</span>

        // Get node role
        <span class="cov8" title="1">nodeRole := ""
        for key := range node.Labels </span><span class="cov8" title="1">{
                if strings.HasPrefix(key, "node-role.kubernetes.io/") </span><span class="cov8" title="1">{
                        role := strings.TrimPrefix(key, "node-role.kubernetes.io/")
                        if role != "" </span><span class="cov8" title="1">{
                                nodeRole = role
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">createdByKind, createdByName := utils.GetOwnerReferenceInfo(node)

        // Get taints
        var taints []types.TaintData
        if node.Spec.Taints != nil </span><span class="cov8" title="1">{
                for _, taint := range node.Spec.Taints </span><span class="cov8" title="1">{
                        taints = append(taints, types.TaintData{
                                Key:    taint.Key,
                                Value:  taint.Value,
                                Effect: string(taint.Effect),
                        })
                }</span>
        }

        <span class="cov8" title="1">data := types.NodeData{
                Architecture:            node.Status.NodeInfo.Architecture,
                OperatingSystem:         node.Status.NodeInfo.OperatingSystem,
                KernelVersion:           node.Status.NodeInfo.KernelVersion,
                KubeletVersion:          node.Status.NodeInfo.KubeletVersion,
                KubeProxyVersion:        node.Status.NodeInfo.KubeProxyVersion,
                ContainerRuntimeVersion: node.Status.NodeInfo.ContainerRuntimeVersion,
                Capacity:                capacity,
                Allocatable:             allocatable,
                Conditions:              conditions,
                Labels:                  utils.ExtractLabels(node),
                Annotations:             utils.ExtractAnnotations(node),
                InternalIP:              internalIP,
                ExternalIP:              externalIP,
                Hostname:                hostname,
                Unschedulable:           node.Spec.Unschedulable,
                Ready:                   ready,
                CreatedByKind:           createdByKind,
                CreatedByName:           createdByName,
                CreatedTimestamp:        utils.ExtractCreationTimestamp(node),
                Role:                    nodeRole,
                Taints:                  taints,
                DeletionTimestamp:       utils.ExtractDeletionTimestamp(node),
                Phase:                   phase,
        }

        return utils.CreateLogEntry("node", utils.ExtractName(node), utils.ExtractNamespace(node), data)</span>
}

// convertToMap converts a struct to map[string]any for JSON serialization
func (h *NodeHandler) convertToMap(data any) map[string]any <span class="cov0" title="0">{
        return utils.ConvertStructToMap(data)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package resources

import (
        "context"
        "time"

        corev1 "k8s.io/api/core/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// PersistentVolumeHandler handles collection of persistentvolume metrics
type PersistentVolumeHandler struct {
        utils.BaseHandler
}

// NewPersistentVolumeHandler creates a new PersistentVolumeHandler
func NewPersistentVolumeHandler(client kubernetes.Interface) *PersistentVolumeHandler <span class="cov8" title="1">{
        return &amp;PersistentVolumeHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the persistentvolume informer
func (h *PersistentVolumeHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create persistentvolume informer
        informer := factory.Core().V1().PersistentVolumes().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers persistentvolume metrics from the cluster (uses cache)
func (h *PersistentVolumeHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all persistentvolumes from the cache
        pvList := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range pvList </span><span class="cov8" title="1">{
                pv, ok := obj.(*corev1.PersistentVolume)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(pv)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a persistentvolume
func (h *PersistentVolumeHandler) createLogEntry(pv *corev1.PersistentVolume) types.LogEntry <span class="cov8" title="1">{
        // Extract access modes
        var accessModes []string
        for _, mode := range pv.Spec.AccessModes </span><span class="cov8" title="1">{
                accessModes = append(accessModes, string(mode))
        }</span>

        // Extract capacity
        <span class="cov8" title="1">capacityBytes := int64(0)
        if pv.Spec.Capacity != nil </span><span class="cov8" title="1">{
                if storage, exists := pv.Spec.Capacity[corev1.ResourceStorage]; exists </span><span class="cov8" title="1">{
                        capacityBytes = storage.Value()
                }</span>
        }

        // Extract reclaim policy
        <span class="cov8" title="1">reclaimPolicy := string(pv.Spec.PersistentVolumeReclaimPolicy)

        // Extract status
        status := string(pv.Status.Phase)

        // Extract storage class name
        storageClassName := ""
        if pv.Spec.StorageClassName != "" </span><span class="cov8" title="1">{
                storageClassName = pv.Spec.StorageClassName
        }</span>

        // Extract volume mode
        <span class="cov8" title="1">volumeMode := string(*pv.Spec.VolumeMode)

        // Extract volume plugin name
        volumePluginName := ""
        if pv.Spec.PersistentVolumeSource.AWSElasticBlockStore != nil </span><span class="cov8" title="1">{
                volumePluginName = "awsElasticBlockStore"
        }</span> else<span class="cov8" title="1"> if pv.Spec.PersistentVolumeSource.AzureDisk != nil </span><span class="cov0" title="0">{
                volumePluginName = "azureDisk"
        }</span> else<span class="cov8" title="1"> if pv.Spec.PersistentVolumeSource.AzureFile != nil </span><span class="cov0" title="0">{
                volumePluginName = "azureFile"
        }</span> else<span class="cov8" title="1"> if pv.Spec.PersistentVolumeSource.CephFS != nil </span><span class="cov0" title="0">{
                volumePluginName = "cephFS"
        }</span> else<span class="cov8" title="1"> if pv.Spec.PersistentVolumeSource.Cinder != nil </span><span class="cov0" title="0">{
                volumePluginName = "cinder"
        }</span> else<span class="cov8" title="1"> if pv.Spec.PersistentVolumeSource.FC != nil </span><span class="cov0" title="0">{
                volumePluginName = "fc"
        }</span> else<span class="cov8" title="1"> if pv.Spec.PersistentVolumeSource.FlexVolume != nil </span><span class="cov0" title="0">{
                volumePluginName = "flexVolume"
        }</span> else<span class="cov8" title="1"> if pv.Spec.PersistentVolumeSource.Flocker != nil </span><span class="cov0" title="0">{
                volumePluginName = "flocker"
        }</span> else<span class="cov8" title="1"> if pv.Spec.PersistentVolumeSource.GCEPersistentDisk != nil </span><span class="cov0" title="0">{
                volumePluginName = "gcePersistentDisk"
        }</span> else<span class="cov8" title="1"> if pv.Spec.PersistentVolumeSource.Glusterfs != nil </span><span class="cov0" title="0">{
                volumePluginName = "glusterfs"
        }</span> else<span class="cov8" title="1"> if pv.Spec.PersistentVolumeSource.HostPath != nil </span><span class="cov8" title="1">{
                volumePluginName = "hostPath"
        }</span> else<span class="cov8" title="1"> if pv.Spec.PersistentVolumeSource.ISCSI != nil </span><span class="cov0" title="0">{
                volumePluginName = "iscsi"
        }</span> else<span class="cov8" title="1"> if pv.Spec.PersistentVolumeSource.Local != nil </span><span class="cov0" title="0">{
                volumePluginName = "local"
        }</span> else<span class="cov8" title="1"> if pv.Spec.PersistentVolumeSource.NFS != nil </span><span class="cov8" title="1">{
                volumePluginName = "nfs"
        }</span> else<span class="cov0" title="0"> if pv.Spec.PersistentVolumeSource.PhotonPersistentDisk != nil </span><span class="cov0" title="0">{
                volumePluginName = "photonPersistentDisk"
        }</span> else<span class="cov0" title="0"> if pv.Spec.PersistentVolumeSource.PortworxVolume != nil </span><span class="cov0" title="0">{
                volumePluginName = "portworxVolume"
        }</span> else<span class="cov0" title="0"> if pv.Spec.PersistentVolumeSource.Quobyte != nil </span><span class="cov0" title="0">{
                volumePluginName = "quobyte"
        }</span> else<span class="cov0" title="0"> if pv.Spec.PersistentVolumeSource.RBD != nil </span><span class="cov0" title="0">{
                volumePluginName = "rbd"
        }</span> else<span class="cov0" title="0"> if pv.Spec.PersistentVolumeSource.ScaleIO != nil </span><span class="cov0" title="0">{
                volumePluginName = "scaleIO"
        }</span> else<span class="cov0" title="0"> if pv.Spec.PersistentVolumeSource.StorageOS != nil </span><span class="cov0" title="0">{
                volumePluginName = "storageOS"
        }</span> else<span class="cov0" title="0"> if pv.Spec.PersistentVolumeSource.VsphereVolume != nil </span><span class="cov0" title="0">{
                volumePluginName = "vsphereVolume"
        }</span> else<span class="cov0" title="0"> {
                volumePluginName = "unknown"
        }</span>

        // Extract persistent volume source
        <span class="cov8" title="1">persistentVolumeSource := volumePluginName

        createdByKind, createdByName := utils.GetOwnerReferenceInfo(pv)

        // Create data structure
        data := types.PersistentVolumeData{
                CreatedTimestamp:       utils.ExtractCreationTimestamp(pv),
                Labels:                 utils.ExtractLabels(pv),
                Annotations:            utils.ExtractAnnotations(pv),
                CapacityBytes:          capacityBytes,
                AccessModes:            accessModes[0], // Take first access mode
                ReclaimPolicy:          reclaimPolicy,
                Status:                 status,
                StorageClassName:       storageClassName,
                VolumeMode:             volumeMode,
                VolumePluginName:       volumePluginName,
                PersistentVolumeSource: persistentVolumeSource,
                CreatedByKind:          createdByKind,
                CreatedByName:          createdByName,
                IsDefaultClass:         false, // This would need to be determined from StorageClass
        }

        return utils.CreateLogEntry("persistentvolume", utils.ExtractName(pv), utils.ExtractNamespace(pv), data)</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package resources

import (
        "context"
        "time"

        corev1 "k8s.io/api/core/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// PersistentVolumeClaimHandler handles collection of persistentvolumeclaim metrics
type PersistentVolumeClaimHandler struct {
        utils.BaseHandler
}

// NewPersistentVolumeClaimHandler creates a new PersistentVolumeClaimHandler
func NewPersistentVolumeClaimHandler(client kubernetes.Interface) *PersistentVolumeClaimHandler <span class="cov8" title="1">{
        return &amp;PersistentVolumeClaimHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the persistentvolumeclaim informer
func (h *PersistentVolumeClaimHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create persistentvolumeclaim informer
        informer := factory.Core().V1().PersistentVolumeClaims().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers persistentvolumeclaim metrics from the cluster (uses cache)
func (h *PersistentVolumeClaimHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all persistentvolumeclaims from the cache
        pvcList := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range pvcList </span><span class="cov8" title="1">{
                pvc, ok := obj.(*corev1.PersistentVolumeClaim)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if !utils.ShouldIncludeNamespace(namespaces, pvc.Namespace) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(pvc)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a persistentvolumeclaim
func (h *PersistentVolumeClaimHandler) createLogEntry(pvc *corev1.PersistentVolumeClaim) types.LogEntry <span class="cov8" title="1">{
        var accessModes []string
        for _, mode := range pvc.Spec.AccessModes </span><span class="cov8" title="1">{
                accessModes = append(accessModes, string(mode))
        }</span>

        <span class="cov8" title="1">var storageClassName *string
        if pvc.Spec.StorageClassName != nil </span><span class="cov8" title="1">{
                storageClassName = pvc.Spec.StorageClassName
        }</span>

        <span class="cov8" title="1">capacity := utils.ExtractResourceMap(pvc.Status.Capacity)

        requestStorage := ""
        if pvc.Spec.Resources.Requests != nil </span><span class="cov8" title="1">{
                if storage, exists := pvc.Spec.Resources.Requests[corev1.ResourceStorage]; exists </span><span class="cov8" title="1">{
                        requestStorage = storage.String()
                }</span>
        }

        <span class="cov8" title="1">usedStorage := ""
        if pvc.Status.Capacity != nil </span><span class="cov8" title="1">{
                if storage, exists := pvc.Status.Capacity[corev1.ResourceStorage]; exists </span><span class="cov8" title="1">{
                        usedStorage = storage.String()
                }</span>
        }

        <span class="cov8" title="1">conditionPending := false
        conditionBound := false
        conditionLost := false
        for _, condition := range pvc.Status.Conditions </span><span class="cov8" title="1">{
                switch condition.Type </span>{
                case "Pending":<span class="cov8" title="1">
                        conditionPending = condition.Status == corev1.ConditionTrue</span>
                case "Bound":<span class="cov8" title="1">
                        conditionBound = condition.Status == corev1.ConditionTrue</span>
                case "Lost":<span class="cov8" title="1">
                        conditionLost = condition.Status == corev1.ConditionTrue</span>
                }
        }

        <span class="cov8" title="1">createdByKind, createdByName := utils.GetOwnerReferenceInfo(pvc)

        data := types.PersistentVolumeClaimData{
                CreatedTimestamp: utils.ExtractCreationTimestamp(pvc),
                Labels:           utils.ExtractLabels(pvc),
                Annotations:      utils.ExtractAnnotations(pvc),
                AccessModes:      accessModes,
                StorageClassName: storageClassName,
                VolumeName:       pvc.Spec.VolumeName,
                Phase:            string(pvc.Status.Phase),
                Capacity:         capacity,
                ConditionPending: conditionPending,
                ConditionBound:   conditionBound,
                ConditionLost:    conditionLost,
                CreatedByKind:    createdByKind,
                CreatedByName:    createdByName,
                RequestStorage:   requestStorage,
                UsedStorage:      usedStorage,
        }

        return utils.CreateLogEntry("persistentvolumeclaim", utils.ExtractName(pvc), utils.ExtractNamespace(pvc), data)</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package resources

import (
        "context"
        "strconv"
        "time"

        corev1 "k8s.io/api/core/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// PodHandler handles collection of pod metrics
type PodHandler struct {
        utils.BaseHandler
}

// NewPodHandler creates a new PodHandler
func NewPodHandler(client kubernetes.Interface) *PodHandler <span class="cov8" title="1">{
        return &amp;PodHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the pod informer
func (h *PodHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create pod informer
        informer := factory.Core().V1().Pods().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers pod metrics from the cluster (uses cache)
func (h *PodHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all pods from the cache
        pods := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range pods </span><span class="cov8" title="1">{
                pod, ok := obj.(*corev1.Pod)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if !utils.ShouldIncludeNamespace(namespaces, pod.Namespace) </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Create pod log entry
                <span class="cov8" title="1">podEntry := h.createPodLogEntry(pod)
                entries = append(entries, podEntry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createPodLogEntry creates a LogEntry from a pod
func (h *PodHandler) createPodLogEntry(pod *corev1.Pod) types.LogEntry <span class="cov8" title="1">{
        // Determine QoS class
        qosClass := string(pod.Status.QOSClass)
        if qosClass == "" </span><span class="cov0" title="0">{
                qosClass = "BestEffort" // Default QoS class when not set
                // See: https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#qos-classes
        }</span>

        // Get priority class
        <span class="cov8" title="1">priorityClass := ""
        if pod.Spec.PriorityClassName != "" </span><span class="cov0" title="0">{
                priorityClass = pod.Spec.PriorityClassName
        }</span>

        <span class="cov8" title="1">createdByKind, createdByName := utils.GetOwnerReferenceInfo(pod)

        // Check pod conditions
        ready := false
        initialized := false
        scheduled := false
        containersReady := false
        podScheduled := false

        for _, condition := range pod.Status.Conditions </span><span class="cov8" title="1">{
                switch condition.Type </span>{
                case corev1.PodReady:<span class="cov8" title="1">
                        ready = condition.Status == corev1.ConditionTrue</span>
                case corev1.PodInitialized:<span class="cov8" title="1">
                        initialized = condition.Status == corev1.ConditionTrue</span>
                case corev1.PodScheduled:<span class="cov8" title="1">
                        scheduled = condition.Status == corev1.ConditionTrue</span>
                case corev1.ContainersReady:<span class="cov8" title="1">
                        containersReady = condition.Status == corev1.ConditionTrue</span>
                }
        }
        <span class="cov8" title="1">podScheduled = scheduled

        // Calculate total restart count
        var totalRestartCount int32
        for _, container := range pod.Status.ContainerStatuses </span><span class="cov8" title="1">{
                totalRestartCount += container.RestartCount
        }</span>

        // Get timestamps
        <span class="cov8" title="1">var deletionTimestamp, startTime, initializedTime, readyTime, scheduledTime *time.Time
        if pod.DeletionTimestamp != nil </span><span class="cov0" title="0">{
                deletionTimestamp = &amp;pod.DeletionTimestamp.Time
        }</span>
        <span class="cov8" title="1">if pod.Status.StartTime != nil &amp;&amp; !pod.Status.StartTime.IsZero() </span><span class="cov8" title="1">{
                startTime = &amp;pod.Status.StartTime.Time
        }</span>

        // Get condition timestamps
        <span class="cov8" title="1">for _, condition := range pod.Status.Conditions </span><span class="cov8" title="1">{
                switch condition.Type </span>{
                case corev1.PodInitialized:<span class="cov8" title="1">
                        if condition.Status == corev1.ConditionTrue &amp;&amp; !condition.LastTransitionTime.IsZero() </span><span class="cov8" title="1">{
                                initializedTime = &amp;condition.LastTransitionTime.Time
                        }</span>
                case corev1.PodReady:<span class="cov8" title="1">
                        if condition.Status == corev1.ConditionTrue &amp;&amp; !condition.LastTransitionTime.IsZero() </span><span class="cov8" title="1">{
                                readyTime = &amp;condition.LastTransitionTime.Time
                        }</span>
                case corev1.PodScheduled:<span class="cov8" title="1">
                        if condition.Status == corev1.ConditionTrue &amp;&amp; !condition.LastTransitionTime.IsZero() </span><span class="cov8" title="1">{
                                scheduledTime = &amp;condition.LastTransitionTime.Time
                        }</span>
                }
        }

        // Get status reason - match kube-state-metrics logic
        // See: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase
        <span class="cov8" title="1">statusReason := ""
        if pod.Status.Reason != "" </span><span class="cov0" title="0">{
                statusReason = pod.Status.Reason
        }</span> else<span class="cov8" title="1"> {
                // Check conditions for reason
                for _, condition := range pod.Status.Conditions </span><span class="cov8" title="1">{
                        if condition.Status == corev1.ConditionFalse &amp;&amp; condition.Reason != "" </span><span class="cov8" title="1">{
                                statusReason = condition.Reason
                                break</span>
                        }
                }
                // Check container statuses for terminated reasons
                <span class="cov8" title="1">if statusReason == "" </span><span class="cov8" title="1">{
                        for _, cs := range pod.Status.ContainerStatuses </span><span class="cov8" title="1">{
                                if cs.State.Terminated != nil &amp;&amp; cs.State.Terminated.Reason != "" </span><span class="cov0" title="0">{
                                        statusReason = string(cs.State.Terminated.Reason)
                                        break</span>
                                }
                        }
                }
        }

        // Get unschedulable status
        <span class="cov8" title="1">unschedulable := false
        for _, condition := range pod.Status.Conditions </span><span class="cov8" title="1">{
                if condition.Type == corev1.PodScheduled &amp;&amp; condition.Status == corev1.ConditionFalse </span><span class="cov8" title="1">{
                        unschedulable = true
                        break</span>
                }
        }

        // Get pod IPs
        <span class="cov8" title="1">var podIPs []string
        if pod.Status.PodIP != "" </span><span class="cov8" title="1">{
                podIPs = append(podIPs, pod.Status.PodIP)
        }</span>
        <span class="cov8" title="1">for _, ip := range pod.Status.PodIPs </span><span class="cov0" title="0">{
                if ip.IP != "" </span><span class="cov0" title="0">{
                        podIPs = append(podIPs, ip.IP)
                }</span>
        }

        // Get tolerations
        <span class="cov8" title="1">var tolerations []types.TolerationData
        for _, toleration := range pod.Spec.Tolerations </span><span class="cov8" title="1">{
                tolerationData := types.TolerationData{
                        Key:      toleration.Key,
                        Value:    toleration.Value,
                        Effect:   string(toleration.Effect),
                        Operator: string(toleration.Operator),
                }

                // Add toleration seconds if present
                if toleration.TolerationSeconds != nil </span><span class="cov8" title="1">{
                        tolerationData.TolerationSeconds = strconv.FormatInt(*toleration.TolerationSeconds, 10)
                }</span>

                <span class="cov8" title="1">tolerations = append(tolerations, tolerationData)</span>
        }

        // Get PVC info
        <span class="cov8" title="1">var pvcs []types.PVCData
        for _, volume := range pod.Spec.Volumes </span><span class="cov8" title="1">{
                if volume.PersistentVolumeClaim != nil </span><span class="cov8" title="1">{
                        readOnly := false
                        for _, mount := range pod.Spec.Containers </span><span class="cov8" title="1">{
                                for _, volumeMount := range mount.VolumeMounts </span><span class="cov8" title="1">{
                                        if volumeMount.Name == volume.Name &amp;&amp; volumeMount.ReadOnly </span><span class="cov8" title="1">{
                                                readOnly = true
                                                break</span>
                                        }
                                }
                        }
                        <span class="cov8" title="1">pvcs = append(pvcs, types.PVCData{
                                ClaimName: volume.PersistentVolumeClaim.ClaimName,
                                ReadOnly:  readOnly,
                        })</span>
                }
        }

        // Get overhead
        <span class="cov8" title="1">overheadCPUCores := ""
        overheadMemoryBytes := ""
        if pod.Spec.Overhead != nil </span><span class="cov0" title="0">{
                if cpu := pod.Spec.Overhead[corev1.ResourceCPU]; !cpu.IsZero() </span><span class="cov0" title="0">{
                        overheadCPUCores = cpu.String()
                }</span>
                <span class="cov0" title="0">if memory := pod.Spec.Overhead[corev1.ResourceMemory]; !memory.IsZero() </span><span class="cov0" title="0">{
                        overheadMemoryBytes = memory.String()
                }</span>
        }

        // Get runtime class name
        <span class="cov8" title="1">runtimeClassName := ""
        if pod.Spec.RuntimeClassName != nil </span><span class="cov0" title="0">{
                runtimeClassName = *pod.Spec.RuntimeClassName
        }</span>

        // Get completion time (when pod phase is Succeeded)
        <span class="cov8" title="1">var completionTime *time.Time
        if pod.Status.Phase == corev1.PodSucceeded &amp;&amp; pod.Status.StartTime != nil &amp;&amp; !pod.Status.StartTime.IsZero() </span><span class="cov8" title="1">{
                completionTime = &amp;pod.Status.StartTime.Time
        }</span>

        // Aggregate pod-level resource requests and limits
        <span class="cov8" title="1">resourceRequests := make(map[string]string)
        resourceLimits := make(map[string]string)

        for _, container := range pod.Spec.Containers </span><span class="cov8" title="1">{
                for key, value := range container.Resources.Requests </span><span class="cov8" title="1">{
                        resourceKey := string(key)
                        if existing, exists := resourceRequests[resourceKey]; exists </span><span class="cov0" title="0">{
                                // Add to existing value (simplified - in reality would need proper resource arithmetic)
                                resourceRequests[resourceKey] = existing + " + " + value.String()
                        }</span> else<span class="cov8" title="1"> {
                                resourceRequests[resourceKey] = value.String()
                        }</span>
                }
                <span class="cov8" title="1">for key, value := range container.Resources.Limits </span><span class="cov8" title="1">{
                        resourceKey := string(key)
                        if existing, exists := resourceLimits[resourceKey]; exists </span><span class="cov0" title="0">{
                                // Add to existing value (simplified - in reality would need proper resource arithmetic)
                                resourceLimits[resourceKey] = existing + " + " + value.String()
                        }</span> else<span class="cov8" title="1"> {
                                resourceLimits[resourceKey] = value.String()
                        }</span>
                }
        }

        <span class="cov8" title="1">data := types.PodData{
                NodeName:               pod.Spec.NodeName,
                HostIP:                 pod.Status.HostIP,
                PodIP:                  pod.Status.PodIP,
                Phase:                  string(pod.Status.Phase),
                QoSClass:               qosClass,
                PriorityClass:          priorityClass,
                Ready:                  ready,
                Initialized:            initialized,
                Scheduled:              scheduled,
                ContainersReady:        containersReady,
                PodScheduled:           podScheduled,
                RestartCount:           totalRestartCount,
                CreatedByKind:          createdByKind,
                CreatedByName:          createdByName,
                Labels:                 utils.ExtractLabels(pod),
                Annotations:            utils.ExtractAnnotations(pod),
                DeletionTimestamp:      deletionTimestamp,
                StartTime:              startTime,
                InitializedTime:        initializedTime,
                ReadyTime:              readyTime,
                ScheduledTime:          scheduledTime,
                StatusReason:           statusReason,
                Unschedulable:          unschedulable,
                RestartPolicy:          string(pod.Spec.RestartPolicy),
                ServiceAccount:         pod.Spec.ServiceAccountName,
                SchedulerName:          pod.Spec.SchedulerName,
                OverheadCPUCores:       overheadCPUCores,
                OverheadMemoryBytes:    overheadMemoryBytes,
                RuntimeClassName:       runtimeClassName,
                PodIPs:                 podIPs,
                Tolerations:            tolerations,
                NodeSelectors:          pod.Spec.NodeSelector,
                PersistentVolumeClaims: pvcs,
                CompletionTime:         completionTime,
                ResourceLimits:         resourceLimits,
                ResourceRequests:       resourceRequests,
        }

        return utils.CreateLogEntry("pod", utils.ExtractName(pod), utils.ExtractNamespace(pod), data)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package resources

import (
        "context"
        "time"

        policyv1 "k8s.io/api/policy/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// PodDisruptionBudgetHandler handles collection of poddisruptionbudget metrics
type PodDisruptionBudgetHandler struct {
        utils.BaseHandler
}

// NewPodDisruptionBudgetHandler creates a new PodDisruptionBudgetHandler
func NewPodDisruptionBudgetHandler(client kubernetes.Interface) *PodDisruptionBudgetHandler <span class="cov8" title="1">{
        return &amp;PodDisruptionBudgetHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the poddisruptionbudget informer
func (h *PodDisruptionBudgetHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create poddisruptionbudget informer
        informer := factory.Policy().V1().PodDisruptionBudgets().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers poddisruptionbudget metrics from the cluster (uses cache)
func (h *PodDisruptionBudgetHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all poddisruptionbudgets from the cache
        pdbList := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range pdbList </span><span class="cov8" title="1">{
                pdb, ok := obj.(*policyv1.PodDisruptionBudget)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if !utils.ShouldIncludeNamespace(namespaces, pdb.Namespace) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(pdb)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a poddisruptionbudget
func (h *PodDisruptionBudgetHandler) createLogEntry(pdb *policyv1.PodDisruptionBudget) types.LogEntry <span class="cov8" title="1">{
        // Get min available and max unavailable
        // See: https://kubernetes.io/docs/concepts/workloads/pods/disruptions/#pod-disruption-budgets
        minAvailable := int32(0)
        maxUnavailable := int32(0)

        if pdb.Spec.MinAvailable != nil </span><span class="cov8" title="1">{
                minAvailable = pdb.Spec.MinAvailable.IntVal
        }</span>
        <span class="cov8" title="1">if pdb.Spec.MaxUnavailable != nil </span><span class="cov8" title="1">{
                maxUnavailable = pdb.Spec.MaxUnavailable.IntVal
        }</span>

        // Get status values
        <span class="cov8" title="1">currentHealthy := pdb.Status.CurrentHealthy
        desiredHealthy := pdb.Status.DesiredHealthy
        expectedPods := pdb.Status.ExpectedPods
        disruptionsAllowed := pdb.Status.DisruptionsAllowed
        disruptionAllowed := disruptionsAllowed &gt; 0

        createdByKind, createdByName := utils.GetOwnerReferenceInfo(pdb)

        // Create data structure
        data := types.PodDisruptionBudgetData{
                CreatedTimestamp:         utils.ExtractCreationTimestamp(pdb),
                Labels:                   utils.ExtractLabels(pdb),
                Annotations:              utils.ExtractAnnotations(pdb),
                MinAvailable:             minAvailable,
                MaxUnavailable:           maxUnavailable,
                CurrentHealthy:           currentHealthy,
                DesiredHealthy:           desiredHealthy,
                ExpectedPods:             expectedPods,
                DisruptionsAllowed:       disruptionsAllowed,
                TotalReplicas:            0, // Not available in v1 API
                DisruptionAllowed:        disruptionAllowed,
                StatusCurrentHealthy:     currentHealthy,
                StatusDesiredHealthy:     desiredHealthy,
                StatusExpectedPods:       expectedPods,
                StatusDisruptionsAllowed: disruptionsAllowed,
                StatusTotalReplicas:      0, // Not available in v1 API
                StatusDisruptionAllowed:  disruptionAllowed,
                CreatedByKind:            createdByKind,
                CreatedByName:            createdByName,
        }

        return utils.CreateLogEntry("poddisruptionbudget", utils.ExtractName(pdb), utils.ExtractNamespace(pdb), data)</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package resources

import (
        "context"
        "time"

        schedulingv1 "k8s.io/api/scheduling/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// PriorityClassHandler handles collection of priorityclass metrics
type PriorityClassHandler struct {
        utils.BaseHandler
}

// NewPriorityClassHandler creates a new PriorityClassHandler
func NewPriorityClassHandler(client kubernetes.Interface) *PriorityClassHandler <span class="cov8" title="1">{
        return &amp;PriorityClassHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the priorityclass informer
func (h *PriorityClassHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create priorityclass informer
        informer := factory.Scheduling().V1().PriorityClasses().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers priorityclass metrics from the cluster (uses cache)
func (h *PriorityClassHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all priorityclasses from the cache
        pcList := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range pcList </span><span class="cov8" title="1">{
                pc, ok := obj.(*schedulingv1.PriorityClass)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(pc)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a PriorityClass
func (h *PriorityClassHandler) createLogEntry(pc *schedulingv1.PriorityClass) types.LogEntry <span class="cov8" title="1">{
        createdTimestamp := utils.ExtractCreationTimestamp(pc)
        createdByKind, createdByName := utils.GetOwnerReferenceInfo(pc)

        preemptionPolicy := ""
        if pc.PreemptionPolicy != nil </span><span class="cov8" title="1">{
                preemptionPolicy = string(*pc.PreemptionPolicy)
        }</span>

        <span class="cov8" title="1">data := types.PriorityClassData{
                CreatedTimestamp: createdTimestamp,
                Labels:           utils.ExtractLabels(pc),
                Annotations:      utils.ExtractAnnotations(pc),
                Value:            pc.Value,
                GlobalDefault:    pc.GlobalDefault,
                Description:      pc.Description,
                PreemptionPolicy: preemptionPolicy,
                CreatedByKind:    createdByKind,
                CreatedByName:    createdByName,
        }

        return utils.CreateLogEntry("priorityclass", utils.ExtractName(pc), utils.ExtractNamespace(pc), data)</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package resources

import (
        "context"
        "slices"
        "time"

        appsv1 "k8s.io/api/apps/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// ReplicaSetHandler handles collection of replicaset metrics
type ReplicaSetHandler struct {
        utils.BaseHandler
}

// NewReplicaSetHandler creates a new ReplicaSetHandler
func NewReplicaSetHandler(client kubernetes.Interface) *ReplicaSetHandler <span class="cov8" title="1">{
        return &amp;ReplicaSetHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the replicaset informer
func (h *ReplicaSetHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create replicaset informer
        informer := factory.Apps().V1().ReplicaSets().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers replicaset metrics from the cluster (uses cache)
func (h *ReplicaSetHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all replicasets from the cache
        replicasets := utils.SafeGetStoreList(h.GetInformer())

        // Group replicasets by owner to identify current ones
        ownerReplicaSets := make(map[string][]*appsv1.ReplicaSet)

        for _, obj := range replicasets </span><span class="cov8" title="1">{
                rs, ok := obj.(*appsv1.ReplicaSet)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if !utils.ShouldIncludeNamespace(namespaces, rs.Namespace) </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Group by owner
                <span class="cov8" title="1">for _, ownerRef := range rs.OwnerReferences </span><span class="cov8" title="1">{
                        key := rs.Namespace + "/" + ownerRef.Kind + "/" + ownerRef.Name
                        ownerReplicaSets[key] = append(ownerReplicaSets[key], rs)
                }</span>
        }

        // Process each group and identify current replicasets
        <span class="cov8" title="1">for _, rsList := range ownerReplicaSets </span><span class="cov8" title="1">{
                if len(rsList) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Sort by creation timestamp (newest first) and generation
                <span class="cov8" title="1">slices.SortFunc(rsList, func(a, b *appsv1.ReplicaSet) int </span><span class="cov0" title="0">{
                        if a.CreationTimestamp.Equal(&amp;b.CreationTimestamp) </span><span class="cov0" title="0">{
                                return int(b.Generation - a.Generation)
                        }</span>
                        <span class="cov0" title="0">return b.CreationTimestamp.Compare(a.CreationTimestamp.Time)</span>
                })

                // Mark the first (newest) replicaset as current
                <span class="cov8" title="1">if len(rsList) &gt; 0 </span><span class="cov8" title="1">{
                        if rsList[0].Labels == nil </span><span class="cov0" title="0">{
                                rsList[0].Labels = make(map[string]string)
                        }</span>
                        <span class="cov8" title="1">rsList[0].Labels["kube-state-logs/current"] = "true"</span>
                }

                // Only log current replicasets
                <span class="cov8" title="1">for _, rs := range rsList </span><span class="cov8" title="1">{
                        if rs.Labels != nil &amp;&amp; rs.Labels["kube-state-logs/current"] == "true" </span><span class="cov8" title="1">{
                                entry := h.createLogEntry(rs)
                                entries = append(entries, entry)
                        }</span>
                }
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a replicaset
func (h *ReplicaSetHandler) createLogEntry(rs *appsv1.ReplicaSet) types.LogEntry <span class="cov8" title="1">{
        createdByKind, createdByName := utils.GetOwnerReferenceInfo(rs)

        // Get desired replicas with nil check
        desiredReplicas := int32(1)
        if rs.Spec.Replicas != nil </span><span class="cov8" title="1">{
                desiredReplicas = *rs.Spec.Replicas
        }</span>

        <span class="cov8" title="1">data := types.ReplicaSetData{
                CreatedTimestamp:        utils.ExtractCreationTimestamp(rs),
                Labels:                  utils.ExtractLabels(rs),
                Annotations:             utils.ExtractAnnotations(rs),
                DesiredReplicas:         desiredReplicas,
                CurrentReplicas:         rs.Status.Replicas,
                ReadyReplicas:           rs.Status.ReadyReplicas,
                AvailableReplicas:       rs.Status.AvailableReplicas,
                FullyLabeledReplicas:    rs.Status.FullyLabeledReplicas,
                ObservedGeneration:      rs.Status.ObservedGeneration,
                ConditionAvailable:      utils.GetConditionStatusGeneric(rs.Status.Conditions, "ReplicaSetAvailable"),
                ConditionProgressing:    utils.GetConditionStatusGeneric(rs.Status.Conditions, "ReplicaSetProgressing"),
                ConditionReplicaFailure: utils.GetConditionStatusGeneric(rs.Status.Conditions, "ReplicaSetReplicaFailure"),
                CreatedByKind:           createdByKind,
                CreatedByName:           createdByName,
                IsCurrent: func() bool </span><span class="cov8" title="1">{
                        if rs.Labels != nil </span><span class="cov8" title="1">{
                                return rs.Labels["kube-state-logs/current"] == "true"
                        }</span>
                        <span class="cov0" title="0">return false</span>
                }(),
        }

        <span class="cov8" title="1">return utils.CreateLogEntry("replicaset", utils.ExtractName(rs), utils.ExtractNamespace(rs), data)</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package resources

import (
        "context"
        "time"

        corev1 "k8s.io/api/core/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// ReplicationControllerHandler handles collection of replicationcontroller metrics
type ReplicationControllerHandler struct {
        utils.BaseHandler
}

// NewReplicationControllerHandler creates a new ReplicationControllerHandler
func NewReplicationControllerHandler(client kubernetes.Interface) *ReplicationControllerHandler <span class="cov8" title="1">{
        return &amp;ReplicationControllerHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the replicationcontroller informer
func (h *ReplicationControllerHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create replicationcontroller informer
        informer := factory.Core().V1().ReplicationControllers().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers replicationcontroller metrics from the cluster (uses cache)
func (h *ReplicationControllerHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all replicationcontrollers from the cache
        rcList := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range rcList </span><span class="cov8" title="1">{
                rc, ok := obj.(*corev1.ReplicationController)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if !utils.ShouldIncludeNamespace(namespaces, rc.Namespace) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(rc)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a replicationcontroller
func (h *ReplicationControllerHandler) createLogEntry(rc *corev1.ReplicationController) types.LogEntry <span class="cov8" title="1">{
        // Get desired replicas
        // Default to 1 when spec.replicas is nil (Kubernetes API default)
        // See: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#replicationcontroller
        desiredReplicas := int32(1) // Default value
        if rc.Spec.Replicas != nil </span><span class="cov8" title="1">{
                desiredReplicas = *rc.Spec.Replicas
        }</span>

        <span class="cov8" title="1">createdByKind, createdByName := utils.GetOwnerReferenceInfo(rc)

        // Create data structure
        data := types.ReplicationControllerData{
                CreatedTimestamp:     utils.ExtractCreationTimestamp(rc),
                Labels:               utils.ExtractLabels(rc),
                Annotations:          utils.ExtractAnnotations(rc),
                DesiredReplicas:      desiredReplicas,
                CurrentReplicas:      rc.Status.Replicas,
                ReadyReplicas:        rc.Status.ReadyReplicas,
                AvailableReplicas:    rc.Status.AvailableReplicas,
                FullyLabeledReplicas: rc.Status.FullyLabeledReplicas,
                CreatedByKind:        createdByKind,
                CreatedByName:        createdByName,
                ObservedGeneration:   rc.Status.ObservedGeneration,
        }

        return utils.CreateLogEntry("replicationcontroller", utils.ExtractName(rc), utils.ExtractNamespace(rc), data)</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package resources

import (
        "context"
        "time"

        corev1 "k8s.io/api/core/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// ResourceQuotaHandler handles collection of resourcequota metrics
type ResourceQuotaHandler struct {
        utils.BaseHandler
}

// NewResourceQuotaHandler creates a new ResourceQuotaHandler
func NewResourceQuotaHandler(client kubernetes.Interface) *ResourceQuotaHandler <span class="cov8" title="1">{
        return &amp;ResourceQuotaHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the resourcequota informer
func (h *ResourceQuotaHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create resourcequota informer
        informer := factory.Core().V1().ResourceQuotas().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers resourcequota metrics from the cluster (uses cache)
func (h *ResourceQuotaHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all resourcequotas from the cache
        rqList := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range rqList </span><span class="cov8" title="1">{
                rq, ok := obj.(*corev1.ResourceQuota)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if !utils.ShouldIncludeNamespace(namespaces, rq.Namespace) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(rq)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a resourcequota
func (h *ResourceQuotaHandler) createLogEntry(rq *corev1.ResourceQuota) types.LogEntry <span class="cov8" title="1">{
        hard := resourceListToInt64Map(rq.Spec.Hard)
        used := resourceListToInt64Map(rq.Status.Used)

        // Format scopes
        // See: https://kubernetes.io/docs/concepts/policy/resource-quotas/#quota-scopes
        scopes := make([]string, len(rq.Spec.Scopes))
        for i, scope := range rq.Spec.Scopes </span><span class="cov8" title="1">{
                scopes[i] = string(scope)
        }</span>

        <span class="cov8" title="1">createdByKind, createdByName := utils.GetOwnerReferenceInfo(rq)

        // Create data structure
        data := types.ResourceQuotaData{
                CreatedTimestamp: utils.ExtractCreationTimestamp(rq),
                Labels:           utils.ExtractLabels(rq),
                Annotations:      utils.ExtractAnnotations(rq),
                Hard:             hard,
                Used:             used,
                CreatedByKind:    createdByKind,
                CreatedByName:    createdByName,
                Scopes:           scopes,
        }

        return utils.CreateLogEntry("resourcequota", utils.ExtractName(rq), utils.ExtractNamespace(rq), data)</span>
}

// resourceListToInt64Map converts corev1.ResourceList to map[string]int64
func resourceListToInt64Map(rl corev1.ResourceList) map[string]int64 <span class="cov8" title="1">{
        result := make(map[string]int64)
        for resourceName, quantity := range rl </span><span class="cov8" title="1">{
                result[string(resourceName)] = quantity.Value()
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package resources

import (
        "context"
        "time"

        rbacv1 "k8s.io/api/rbac/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// RoleHandler handles collection of role metrics
type RoleHandler struct {
        utils.BaseHandler
}

// NewRoleHandler creates a new RoleHandler
func NewRoleHandler(client kubernetes.Interface) *RoleHandler <span class="cov8" title="1">{
        return &amp;RoleHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the role informer
func (h *RoleHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov0" title="0">{
        // Create role informer
        informer := factory.Rbac().V1().Roles().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers role metrics from the cluster (uses cache)
func (h *RoleHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all roles from the cache
        roleList := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range roleList </span><span class="cov8" title="1">{
                role, ok := obj.(*rbacv1.Role)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if !utils.ShouldIncludeNamespace(namespaces, role.Namespace) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(role)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a role
func (h *RoleHandler) createLogEntry(role *rbacv1.Role) types.LogEntry <span class="cov8" title="1">{
        // Convert rules
        // See: https://kubernetes.io/docs/reference/access-authn-authz/rbac/#role-and-clusterrole
        var rules []types.PolicyRule
        for _, rule := range role.Rules </span><span class="cov8" title="1">{
                policyRule := types.PolicyRule{
                        APIGroups:     rule.APIGroups,
                        Resources:     rule.Resources,
                        ResourceNames: rule.ResourceNames,
                        Verbs:         rule.Verbs,
                }
                rules = append(rules, policyRule)
        }</span>

        // Get created by info
        <span class="cov8" title="1">createdByKind, createdByName := utils.GetOwnerReferenceInfo(role)

        // Create data structure
        data := types.RoleData{
                CreatedTimestamp: utils.ExtractCreationTimestamp(role),
                Labels:           utils.ExtractLabels(role),
                Annotations:      utils.ExtractAnnotations(role),
                Rules:            rules,
                CreatedByKind:    createdByKind,
                CreatedByName:    createdByName,
        }

        return utils.CreateLogEntry("role", utils.ExtractName(role), utils.ExtractNamespace(role), data)</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package resources

import (
        "context"
        "time"

        rbacv1 "k8s.io/api/rbac/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// RoleBindingHandler handles collection of rolebinding metrics
type RoleBindingHandler struct {
        utils.BaseHandler
}

// NewRoleBindingHandler creates a new RoleBindingHandler
func NewRoleBindingHandler(client kubernetes.Interface) *RoleBindingHandler <span class="cov8" title="1">{
        return &amp;RoleBindingHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the rolebinding informer
func (h *RoleBindingHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov0" title="0">{
        // Create rolebinding informer
        informer := factory.Rbac().V1().RoleBindings().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers rolebinding metrics from the cluster (uses cache)
func (h *RoleBindingHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all rolebindings from the cache
        rbList := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range rbList </span><span class="cov8" title="1">{
                rb, ok := obj.(*rbacv1.RoleBinding)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if !utils.ShouldIncludeNamespace(namespaces, rb.Namespace) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(rb)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a rolebinding
func (h *RoleBindingHandler) createLogEntry(rb *rbacv1.RoleBinding) types.LogEntry <span class="cov8" title="1">{
        // Convert role ref
        roleRef := types.RoleRef{
                APIGroup: rb.RoleRef.APIGroup,
                Kind:     rb.RoleRef.Kind,
                Name:     rb.RoleRef.Name,
        }

        // Convert subjects
        var subjects []types.Subject
        for _, subject := range rb.Subjects </span><span class="cov8" title="1">{
                subj := types.Subject{
                        Kind:      subject.Kind,
                        Name:      subject.Name,
                        Namespace: subject.Namespace,
                        APIGroup:  subject.APIGroup,
                }
                subjects = append(subjects, subj)
        }</span>

        <span class="cov8" title="1">createdByKind, createdByName := utils.GetOwnerReferenceInfo(rb)

        // Create data structure
        data := types.RoleBindingData{
                CreatedTimestamp: utils.ExtractCreationTimestamp(rb),
                Labels:           utils.ExtractLabels(rb),
                Annotations:      utils.ExtractAnnotations(rb),
                RoleRef:          roleRef,
                Subjects:         subjects,
                CreatedByKind:    createdByKind,
                CreatedByName:    createdByName,
        }

        return utils.CreateLogEntry("rolebinding", utils.ExtractName(rb), utils.ExtractNamespace(rb), data)</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package resources

import (
        "context"
        "time"

        nodev1 "k8s.io/api/node/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// RuntimeClassHandler handles collection of runtimeclass metrics
type RuntimeClassHandler struct {
        utils.BaseHandler
}

// NewRuntimeClassHandler creates a new RuntimeClassHandler
func NewRuntimeClassHandler(client kubernetes.Interface) *RuntimeClassHandler <span class="cov8" title="1">{
        return &amp;RuntimeClassHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the runtimeclass informer
func (h *RuntimeClassHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create runtimeclass informer
        informer := factory.Node().V1().RuntimeClasses().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers runtimeclass metrics from the cluster (uses cache)
func (h *RuntimeClassHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all runtimeclasses from the cache
        rcList := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range rcList </span><span class="cov8" title="1">{
                rc, ok := obj.(*nodev1.RuntimeClass)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(rc)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a RuntimeClass
func (h *RuntimeClassHandler) createLogEntry(rc *nodev1.RuntimeClass) types.LogEntry <span class="cov8" title="1">{
        createdByKind, createdByName := utils.GetOwnerReferenceInfo(rc)

        // Create data structure
        // See: https://kubernetes.io/docs/concepts/containers/runtime-class/
        data := types.RuntimeClassData{
                CreatedTimestamp: utils.ExtractCreationTimestamp(rc),
                Labels:           utils.ExtractLabels(rc),
                Annotations:      utils.ExtractAnnotations(rc),
                Handler:          rc.Handler,
                CreatedByKind:    createdByKind,
                CreatedByName:    createdByName,
        }

        return utils.CreateLogEntry("runtimeclass", utils.ExtractName(rc), utils.ExtractNamespace(rc), data)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package resources

import (
        "context"
        "time"

        corev1 "k8s.io/api/core/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// SecretHandler handles collection of secret metrics
type SecretHandler struct {
        utils.BaseHandler
}

// NewSecretHandler creates a new SecretHandler
func NewSecretHandler(client kubernetes.Interface) *SecretHandler <span class="cov8" title="1">{
        return &amp;SecretHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the secret informer
func (h *SecretHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create secret informer
        informer := factory.Core().V1().Secrets().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers secret metrics from the cluster (uses cache)
func (h *SecretHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all secrets from the cache
        secrets := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range secrets </span><span class="cov8" title="1">{
                secret, ok := obj.(*corev1.Secret)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if !utils.ShouldIncludeNamespace(namespaces, secret.Namespace) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(secret)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a secret
func (h *SecretHandler) createLogEntry(secret *corev1.Secret) types.LogEntry <span class="cov8" title="1">{
        createdByKind, createdByName := utils.GetOwnerReferenceInfo(secret)

        var dataKeys []string
        for key := range secret.Data </span><span class="cov8" title="1">{
                dataKeys = append(dataKeys, key)
        }</span>

        <span class="cov8" title="1">data := types.SecretData{
                CreatedTimestamp: utils.ExtractCreationTimestamp(secret),
                Labels:           utils.ExtractLabels(secret),
                Annotations:      utils.ExtractAnnotations(secret),
                Type:             string(secret.Type),
                DataKeys:         dataKeys,
                CreatedByKind:    createdByKind,
                CreatedByName:    createdByName,
        }

        return utils.CreateLogEntry("secret", utils.ExtractName(secret), utils.ExtractNamespace(secret), data)</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package resources

import (
        "context"
        "time"

        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/util/intstr"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/tools/cache"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// ServiceHandler handles collection of service metrics
type ServiceHandler struct {
        utils.BaseHandler
        endpointsInformer cache.SharedIndexInformer
}

// NewServiceHandler creates a new ServiceHandler
func NewServiceHandler(client kubernetes.Interface) *ServiceHandler <span class="cov8" title="1">{
        return &amp;ServiceHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the service informer
func (h *ServiceHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create service informer
        serviceInformer := factory.Core().V1().Services().Informer()
        h.SetupBaseInformer(serviceInformer, logger)

        // Create endpoints informer
        h.endpointsInformer = factory.Core().V1().Endpoints().Informer()

        return nil
}</span>

// Collect gathers service metrics from the cluster (uses cache)
func (h *ServiceHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all services from the cache
        services := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range services </span><span class="cov8" title="1">{
                service, ok := obj.(*corev1.Service)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if !utils.ShouldIncludeNamespace(namespaces, service.Namespace) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(service)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a service
func (h *ServiceHandler) createLogEntry(service *corev1.Service) types.LogEntry <span class="cov8" title="1">{
        // Convert ports
        var ports []types.ServicePortData
        for _, port := range service.Spec.Ports </span><span class="cov8" title="1">{
                targetPort := int32(0)
                if port.TargetPort.Type == intstr.Int </span><span class="cov8" title="1">{
                        targetPort = port.TargetPort.IntVal
                }</span> else<span class="cov0" title="0"> if port.TargetPort.Type == intstr.String </span><span class="cov0" title="0">{
                        // For string target ports, we'll use 0 as default
                        // In a real implementation, you might want to resolve the port name
                        // See: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
                        targetPort = 0
                }</span>

                <span class="cov8" title="1">ports = append(ports, types.ServicePortData{
                        Name:       port.Name,
                        Protocol:   string(port.Protocol),
                        Port:       port.Port,
                        TargetPort: targetPort,
                        NodePort:   port.NodePort,
                })</span>
        }

        // Get external IP
        <span class="cov8" title="1">var externalIP string
        if len(service.Spec.ExternalIPs) &gt; 0 </span><span class="cov0" title="0">{
                externalIP = service.Spec.ExternalIPs[0]
        }</span>

        // Get load balancer info
        <span class="cov8" title="1">var loadBalancerIngress []types.LoadBalancerIngressData
        if service.Spec.Type == corev1.ServiceTypeLoadBalancer &amp;&amp; service.Status.LoadBalancer.Ingress != nil </span><span class="cov0" title="0">{
                for _, ingress := range service.Status.LoadBalancer.Ingress </span><span class="cov0" title="0">{
                        loadBalancerIngress = append(loadBalancerIngress, types.LoadBalancerIngressData{
                                IP:       ingress.IP,
                                Hostname: ingress.Hostname,
                        })
                }</span>
        }

        // Count endpoints for this service
        <span class="cov8" title="1">endpointsCount := h.countEndpointsForService(service.Namespace, service.Name)

        createdByKind, createdByName := utils.GetOwnerReferenceInfo(service)

        // Get traffic policies
        internalTrafficPolicy := ""
        if service.Spec.InternalTrafficPolicy != nil </span><span class="cov0" title="0">{
                internalTrafficPolicy = string(*service.Spec.InternalTrafficPolicy)
        }</span>
        <span class="cov8" title="1">externalTrafficPolicy := string(service.Spec.ExternalTrafficPolicy)

        // Get session affinity timeout
        sessionAffinityTimeout := int32(0)
        if service.Spec.SessionAffinityConfig != nil &amp;&amp;
                service.Spec.SessionAffinityConfig.ClientIP != nil &amp;&amp;
                service.Spec.SessionAffinityConfig.ClientIP.TimeoutSeconds != nil </span><span class="cov0" title="0">{
                sessionAffinityTimeout = *service.Spec.SessionAffinityConfig.ClientIP.TimeoutSeconds
        }</span>

        // Get additional service spec fields
        <span class="cov8" title="1">var allocateLoadBalancerNodePorts *bool
        if service.Spec.AllocateLoadBalancerNodePorts != nil </span><span class="cov0" title="0">{
                allocateLoadBalancerNodePorts = service.Spec.AllocateLoadBalancerNodePorts
        }</span>

        <span class="cov8" title="1">var loadBalancerClass *string
        if service.Spec.LoadBalancerClass != nil </span><span class="cov0" title="0">{
                loadBalancerClass = service.Spec.LoadBalancerClass
        }</span>

        <span class="cov8" title="1">data := types.ServiceData{
                Type:                                  string(service.Spec.Type),
                ClusterIP:                             service.Spec.ClusterIP,
                ExternalIP:                            externalIP,
                LoadBalancerIP:                        service.Spec.LoadBalancerIP,
                Ports:                                 ports,
                Selector:                              service.Spec.Selector,
                Labels:                                utils.ExtractLabels(service),
                Annotations:                           utils.ExtractAnnotations(service),
                EndpointsCount:                        endpointsCount,
                LoadBalancerIngress:                   loadBalancerIngress,
                SessionAffinity:                       string(service.Spec.SessionAffinity),
                ExternalName:                          service.Spec.ExternalName,
                CreatedByKind:                         createdByKind,
                CreatedByName:                         createdByName,
                CreatedTimestamp:                      utils.ExtractCreationTimestamp(service),
                InternalTrafficPolicy:                 internalTrafficPolicy,
                ExternalTrafficPolicy:                 externalTrafficPolicy,
                SessionAffinityClientIPTimeoutSeconds: sessionAffinityTimeout,
                AllocateLoadBalancerNodePorts:         allocateLoadBalancerNodePorts,
                LoadBalancerClass:                     loadBalancerClass,
                LoadBalancerSourceRanges:              service.Spec.LoadBalancerSourceRanges,
        }

        return utils.CreateLogEntry("service", utils.ExtractName(service), utils.ExtractNamespace(service), data)</span>
}

// countEndpointsForService counts the number of endpoints for a given service
func (h *ServiceHandler) countEndpointsForService(namespace, serviceName string) int <span class="cov8" title="1">{
        // Get all endpoints from the cache
        endpoints := utils.SafeGetStoreList(h.endpointsInformer)

        for _, obj := range endpoints </span><span class="cov8" title="1">{
                endpoint, ok := obj.(*corev1.Endpoints)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if this endpoint matches the service
                <span class="cov8" title="1">if endpoint.Namespace == namespace &amp;&amp; endpoint.Name == serviceName </span><span class="cov8" title="1">{
                        // Count all addresses across all subsets
                        totalAddresses := 0
                        for _, subset := range endpoint.Subsets </span><span class="cov8" title="1">{
                                if subset.Addresses != nil </span><span class="cov8" title="1">{
                                        totalAddresses += len(subset.Addresses)
                                }</span>
                        }
                        <span class="cov8" title="1">return totalAddresses</span>
                }
        }

        <span class="cov8" title="1">return 0</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package resources

import (
        "context"
        "time"

        corev1 "k8s.io/api/core/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// ServiceAccountHandler handles collection of serviceaccount metrics
type ServiceAccountHandler struct {
        utils.BaseHandler
}

// NewServiceAccountHandler creates a new ServiceAccountHandler
func NewServiceAccountHandler(client kubernetes.Interface) *ServiceAccountHandler <span class="cov8" title="1">{
        return &amp;ServiceAccountHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the serviceaccount informer
func (h *ServiceAccountHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create serviceaccount informer
        informer := factory.Core().V1().ServiceAccounts().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers serviceaccount metrics from the cluster (uses cache)
func (h *ServiceAccountHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all serviceaccounts from the cache
        serviceAccounts := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range serviceAccounts </span><span class="cov8" title="1">{
                sa, ok := obj.(*corev1.ServiceAccount)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if !utils.ShouldIncludeNamespace(namespaces, sa.Namespace) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(sa)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a serviceaccount
func (h *ServiceAccountHandler) createLogEntry(sa *corev1.ServiceAccount) types.LogEntry <span class="cov8" title="1">{
        // Extract secrets
        var secrets []string
        for _, secret := range sa.Secrets </span><span class="cov8" title="1">{
                secrets = append(secrets, secret.Name)
        }</span>

        // Extract image pull secrets
        <span class="cov8" title="1">var imagePullSecrets []string
        for _, secret := range sa.ImagePullSecrets </span><span class="cov8" title="1">{
                imagePullSecrets = append(imagePullSecrets, secret.Name)
        }</span>

        // Get automount service account token setting
        // Default is true when automountServiceAccountToken is nil
        // See: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server
        <span class="cov8" title="1">automountToken := true
        if sa.AutomountServiceAccountToken != nil </span><span class="cov8" title="1">{
                automountToken = *sa.AutomountServiceAccountToken
        }</span>

        <span class="cov8" title="1">createdByKind, createdByName := utils.GetOwnerReferenceInfo(sa)

        // Create data structure
        data := types.ServiceAccountData{
                CreatedTimestamp:             utils.ExtractCreationTimestamp(sa),
                Labels:                       utils.ExtractLabels(sa),
                Annotations:                  utils.ExtractAnnotations(sa),
                Secrets:                      secrets,
                ImagePullSecrets:             imagePullSecrets,
                CreatedByKind:                createdByKind,
                CreatedByName:                createdByName,
                AutomountServiceAccountToken: &amp;automountToken,
        }

        return utils.CreateLogEntry("serviceaccount", utils.ExtractName(sa), utils.ExtractNamespace(sa), data)</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package resources

import (
        "context"
        "time"

        appsv1 "k8s.io/api/apps/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// StatefulSetHandler handles collection of statefulset metrics
type StatefulSetHandler struct {
        utils.BaseHandler
}

// NewStatefulSetHandler creates a new StatefulSetHandler
func NewStatefulSetHandler(client kubernetes.Interface) *StatefulSetHandler <span class="cov8" title="1">{
        return &amp;StatefulSetHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the statefulset informer
func (h *StatefulSetHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create statefulset informer
        informer := factory.Apps().V1().StatefulSets().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers statefulset metrics from the cluster (uses cache)
func (h *StatefulSetHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all statefulsets from the cache
        statefulsets := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range statefulsets </span><span class="cov8" title="1">{
                sts, ok := obj.(*appsv1.StatefulSet)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if !utils.ShouldIncludeNamespace(namespaces, sts.Namespace) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(sts)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a statefulset
func (h *StatefulSetHandler) createLogEntry(sts *appsv1.StatefulSet) types.LogEntry <span class="cov8" title="1">{
        createdByKind, createdByName := utils.GetOwnerReferenceInfo(sts)

        serviceName := ""
        if sts.Spec.ServiceName != "" </span><span class="cov8" title="1">{
                serviceName = sts.Spec.ServiceName
        }</span>

        <span class="cov8" title="1">podManagementPolicy := string(sts.Spec.PodManagementPolicy)
        updateStrategy := string(sts.Spec.UpdateStrategy.Type)

        desiredReplicas := int32(1)
        if sts.Spec.Replicas != nil </span><span class="cov8" title="1">{
                desiredReplicas = *sts.Spec.Replicas
        }</span>

        <span class="cov8" title="1">data := types.StatefulSetData{
                CreatedTimestamp:        utils.ExtractCreationTimestamp(sts),
                Labels:                  utils.ExtractLabels(sts),
                Annotations:             utils.ExtractAnnotations(sts),
                DesiredReplicas:         desiredReplicas,
                CurrentReplicas:         sts.Status.Replicas,
                ReadyReplicas:           sts.Status.ReadyReplicas,
                UpdatedReplicas:         sts.Status.UpdatedReplicas,
                ObservedGeneration:      sts.Status.ObservedGeneration,
                CurrentRevision:         sts.Status.CurrentRevision,
                UpdateRevision:          sts.Status.UpdateRevision,
                ConditionAvailable:      utils.GetConditionStatusGeneric(sts.Status.Conditions, "StatefulSetAvailable"),
                ConditionProgressing:    utils.GetConditionStatusGeneric(sts.Status.Conditions, "StatefulSetProgressing"),
                ConditionReplicaFailure: utils.GetConditionStatusGeneric(sts.Status.Conditions, "StatefulSetReplicaFailure"),
                CreatedByKind:           createdByKind,
                CreatedByName:           createdByName,
                ServiceName:             serviceName,
                PodManagementPolicy:     podManagementPolicy,
                UpdateStrategy:          updateStrategy,
        }

        return utils.CreateLogEntry("statefulset", utils.ExtractName(sts), utils.ExtractNamespace(sts), data)</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package resources

import (
        "context"
        "time"

        storagev1 "k8s.io/api/storage/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// StorageClassHandler handles collection of storageclass metrics
type StorageClassHandler struct {
        utils.BaseHandler
}

// NewStorageClassHandler creates a new StorageClassHandler
func NewStorageClassHandler(client kubernetes.Interface) *StorageClassHandler <span class="cov8" title="1">{
        return &amp;StorageClassHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the storageclass informer
func (h *StorageClassHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create storageclass informer
        informer := factory.Storage().V1().StorageClasses().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers storageclass metrics from the cluster (uses cache)
func (h *StorageClassHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all storageclasses from the cache
        scList := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range scList </span><span class="cov8" title="1">{
                sc, ok := obj.(*storagev1.StorageClass)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(sc)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a storageclass
func (h *StorageClassHandler) createLogEntry(sc *storagev1.StorageClass) types.LogEntry <span class="cov8" title="1">{
        // Get reclaim policy
        // Default is "Delete" when reclaimPolicy is nil
        // See: https://kubernetes.io/docs/concepts/storage/storage-classes/#reclaim-policy
        reclaimPolicy := ""
        if sc.ReclaimPolicy != nil </span><span class="cov8" title="1">{
                reclaimPolicy = string(*sc.ReclaimPolicy)
        }</span>

        // Get volume binding mode
        // Default is "Immediate" when volumeBindingMode is nil
        // See: https://kubernetes.io/docs/concepts/storage/storage-classes/#volume-binding-mode
        <span class="cov8" title="1">volumeBindingMode := ""
        if sc.VolumeBindingMode != nil </span><span class="cov8" title="1">{
                volumeBindingMode = string(*sc.VolumeBindingMode)
        }</span>

        // Get allow volume expansion
        // Default is false when allowVolumeExpansion is nil
        // See: https://kubernetes.io/docs/concepts/storage/storage-classes/#allow-volume-expansion
        <span class="cov8" title="1">allowVolumeExpansion := false
        if sc.AllowVolumeExpansion != nil </span><span class="cov8" title="1">{
                allowVolumeExpansion = *sc.AllowVolumeExpansion
        }</span>

        // Get parameters
        <span class="cov8" title="1">parameters := make(map[string]string)
        if sc.Parameters != nil </span><span class="cov8" title="1">{
                for key, value := range sc.Parameters </span><span class="cov8" title="1">{
                        parameters[key] = value
                }</span>
        }

        // Get mount options
        <span class="cov8" title="1">mountOptions := sc.MountOptions

        // Get allowed topologies
        allowedTopologies := make(map[string]any)
        if sc.AllowedTopologies != nil </span><span class="cov8" title="1">{
                // Convert to map for JSON serialization
                allowedTopologies["allowedTopologies"] = sc.AllowedTopologies
        }</span>

        // Check if this is the default storage class
        <span class="cov8" title="1">isDefaultClass := false
        annotations := utils.ExtractAnnotations(sc)
        if annotations != nil </span><span class="cov8" title="1">{
                if annotations["storageclass.kubernetes.io/is-default-class"] == "true" </span><span class="cov8" title="1">{
                        isDefaultClass = true
                }</span>
        }

        <span class="cov8" title="1">createdByKind, createdByName := utils.GetOwnerReferenceInfo(sc)

        // Create data structure
        data := types.StorageClassData{
                CreatedTimestamp:     utils.ExtractCreationTimestamp(sc),
                Labels:               utils.ExtractLabels(sc),
                Annotations:          annotations,
                Provisioner:          sc.Provisioner,
                ReclaimPolicy:        reclaimPolicy,
                VolumeBindingMode:    volumeBindingMode,
                AllowVolumeExpansion: allowVolumeExpansion,
                Parameters:           parameters,
                MountOptions:         mountOptions,
                AllowedTopologies:    allowedTopologies,
                CreatedByKind:        createdByKind,
                CreatedByName:        createdByName,
                IsDefaultClass:       isDefaultClass,
        }

        return utils.CreateLogEntry("storageclass", utils.ExtractName(sc), utils.ExtractNamespace(sc), data)</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package resources

import (
        "context"
        "time"

        admissionregistrationv1beta1 "k8s.io/api/admissionregistration/v1beta1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// ValidatingAdmissionPolicyHandler handles collection of validatingadmissionpolicy metrics
type ValidatingAdmissionPolicyHandler struct {
        utils.BaseHandler
}

// NewValidatingAdmissionPolicyHandler creates a new ValidatingAdmissionPolicyHandler
func NewValidatingAdmissionPolicyHandler(client kubernetes.Interface) *ValidatingAdmissionPolicyHandler <span class="cov8" title="1">{
        return &amp;ValidatingAdmissionPolicyHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the validatingadmissionpolicy informer
func (h *ValidatingAdmissionPolicyHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov0" title="0">{
        // Create validatingadmissionpolicy informer
        informer := factory.Admissionregistration().V1beta1().ValidatingAdmissionPolicies().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers validatingadmissionpolicy metrics from the cluster (uses cache)
func (h *ValidatingAdmissionPolicyHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all validatingadmissionpolicies from the cache
        vapList := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range vapList </span><span class="cov8" title="1">{
                vap, ok := obj.(*admissionregistrationv1beta1.ValidatingAdmissionPolicy)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(vap)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a ValidatingAdmissionPolicy
func (h *ValidatingAdmissionPolicyHandler) createLogEntry(vap *admissionregistrationv1beta1.ValidatingAdmissionPolicy) types.LogEntry <span class="cov8" title="1">{
        createdTimestamp := utils.ExtractCreationTimestamp(vap)
        createdByKind, createdByName := utils.GetOwnerReferenceInfo(vap)

        failurePolicy := ""
        if vap.Spec.FailurePolicy != nil </span><span class="cov8" title="1">{
                failurePolicy = string(*vap.Spec.FailurePolicy)
        }</span>

        <span class="cov8" title="1">paramKind := ""
        if vap.Spec.ParamKind != nil </span><span class="cov8" title="1">{
                paramKind = vap.Spec.ParamKind.Kind
        }</span>

        <span class="cov8" title="1">observedGeneration := int64(0)
        if vap.Status.ObservedGeneration != 0 </span><span class="cov8" title="1">{
                observedGeneration = vap.Status.ObservedGeneration
        }</span>

        <span class="cov8" title="1">data := types.ValidatingAdmissionPolicyData{
                CreatedTimestamp:   createdTimestamp,
                Labels:             vap.GetLabels(),
                Annotations:        vap.GetAnnotations(),
                FailurePolicy:      failurePolicy,
                MatchConstraints:   []string{},
                Validations:        []string{},
                AuditAnnotations:   []string{},
                MatchConditions:    []string{},
                Variables:          []string{},
                ParamKind:          paramKind,
                ObservedGeneration: observedGeneration,
                TypeChecking:       "",
                ExpressionWarnings: []string{},
                CreatedByKind:      createdByKind,
                CreatedByName:      createdByName,
        }

        return utils.CreateLogEntry("validatingadmissionpolicy", utils.ExtractName(vap), utils.ExtractNamespace(vap), data)</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package resources

import (
        "context"
        "time"

        admissionregistrationv1beta1 "k8s.io/api/admissionregistration/v1beta1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// ValidatingAdmissionPolicyBindingHandler handles collection of validatingadmissionpolicybinding metrics
type ValidatingAdmissionPolicyBindingHandler struct {
        utils.BaseHandler
}

// NewValidatingAdmissionPolicyBindingHandler creates a new ValidatingAdmissionPolicyBindingHandler
func NewValidatingAdmissionPolicyBindingHandler(client kubernetes.Interface) *ValidatingAdmissionPolicyBindingHandler <span class="cov8" title="1">{
        return &amp;ValidatingAdmissionPolicyBindingHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the validatingadmissionpolicybinding informer
func (h *ValidatingAdmissionPolicyBindingHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov0" title="0">{
        // Create validatingadmissionpolicybinding informer
        informer := factory.Admissionregistration().V1beta1().ValidatingAdmissionPolicyBindings().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers validatingadmissionpolicybinding metrics from the cluster (uses cache)
func (h *ValidatingAdmissionPolicyBindingHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all validatingadmissionpolicybindings from the cache
        vapbList := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range vapbList </span><span class="cov8" title="1">{
                vapb, ok := obj.(*admissionregistrationv1beta1.ValidatingAdmissionPolicyBinding)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(vapb)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a ValidatingAdmissionPolicyBinding
func (h *ValidatingAdmissionPolicyBindingHandler) createLogEntry(vapb *admissionregistrationv1beta1.ValidatingAdmissionPolicyBinding) types.LogEntry <span class="cov8" title="1">{
        createdTimestamp := utils.ExtractCreationTimestamp(vapb)
        createdByKind, createdByName := utils.GetOwnerReferenceInfo(vapb)

        policyName := ""
        if vapb.Spec.PolicyName != "" </span><span class="cov8" title="1">{
                policyName = vapb.Spec.PolicyName
        }</span>

        <span class="cov8" title="1">paramRef := ""
        if vapb.Spec.ParamRef != nil </span><span class="cov8" title="1">{
                paramRef = vapb.Spec.ParamRef.Name
        }</span>

        <span class="cov8" title="1">observedGeneration := int64(0)

        data := types.ValidatingAdmissionPolicyBindingData{
                CreatedTimestamp:   createdTimestamp,
                Labels:             vapb.GetLabels(),
                Annotations:        vapb.GetAnnotations(),
                PolicyName:         policyName,
                ParamRef:           paramRef,
                MatchResources:     []string{},
                ValidationActions:  []string{},
                ObservedGeneration: observedGeneration,
                CreatedByKind:      createdByKind,
                CreatedByName:      createdByName,
        }

        return utils.CreateLogEntry("validatingadmissionpolicybinding", utils.ExtractName(vapb), utils.ExtractNamespace(vapb), data)</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package resources

import (
        "context"
        "time"

        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// ValidatingWebhookConfigurationHandler handles collection of validatingwebhookconfiguration metrics
type ValidatingWebhookConfigurationHandler struct {
        utils.BaseHandler
}

// NewValidatingWebhookConfigurationHandler creates a new ValidatingWebhookConfigurationHandler
func NewValidatingWebhookConfigurationHandler(client kubernetes.Interface) *ValidatingWebhookConfigurationHandler <span class="cov8" title="1">{
        return &amp;ValidatingWebhookConfigurationHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the validatingwebhookconfiguration informer
func (h *ValidatingWebhookConfigurationHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov8" title="1">{
        // Create validatingwebhookconfiguration informer
        informer := factory.Admissionregistration().V1().ValidatingWebhookConfigurations().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers validatingwebhookconfiguration metrics from the cluster (uses cache)
func (h *ValidatingWebhookConfigurationHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all validatingwebhookconfigurations from the cache
        vwcList := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range vwcList </span><span class="cov8" title="1">{
                vwc, ok := obj.(*admissionregistrationv1.ValidatingWebhookConfiguration)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(vwc)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a validatingwebhookconfiguration
func (h *ValidatingWebhookConfigurationHandler) createLogEntry(vwc *admissionregistrationv1.ValidatingWebhookConfiguration) types.LogEntry <span class="cov8" title="1">{
        // Extract webhooks
        var webhooks []types.WebhookData
        for _, webhook := range vwc.Webhooks </span><span class="cov8" title="1">{
                // Extract client config
                var clientConfig types.WebhookClientConfigData
                if webhook.ClientConfig.URL != nil </span><span class="cov8" title="1">{
                        clientConfig.URL = *webhook.ClientConfig.URL
                }</span>
                <span class="cov8" title="1">if webhook.ClientConfig.Service != nil </span><span class="cov8" title="1">{
                        path := ""
                        if webhook.ClientConfig.Service.Path != nil </span><span class="cov8" title="1">{
                                path = *webhook.ClientConfig.Service.Path
                        }</span>
                        <span class="cov8" title="1">port := int32(0)
                        if webhook.ClientConfig.Service.Port != nil </span><span class="cov8" title="1">{
                                port = *webhook.ClientConfig.Service.Port
                        }</span>
                        <span class="cov8" title="1">clientConfig.Service = &amp;types.WebhookServiceData{
                                Namespace: webhook.ClientConfig.Service.Namespace,
                                Name:      webhook.ClientConfig.Service.Name,
                                Path:      path,
                                Port:      port,
                        }</span>
                }
                <span class="cov8" title="1">clientConfig.CABundle = webhook.ClientConfig.CABundle

                // Extract rules
                var rules []types.WebhookRuleData
                for _, rule := range webhook.Rules </span><span class="cov8" title="1">{
                        rules = append(rules, types.WebhookRuleData{
                                APIGroups:   rule.APIGroups,
                                APIVersions: rule.APIVersions,
                                Resources:   rule.Resources,
                                Scope:       string(*rule.Scope),
                        })
                }</span>

                // Extract selectors
                <span class="cov8" title="1">var namespaceSelector map[string]string
                if webhook.NamespaceSelector != nil </span><span class="cov8" title="1">{
                        namespaceSelector = webhook.NamespaceSelector.MatchLabels
                }</span>

                <span class="cov8" title="1">var objectSelector map[string]string
                if webhook.ObjectSelector != nil </span><span class="cov8" title="1">{
                        objectSelector = webhook.ObjectSelector.MatchLabels
                }</span>

                <span class="cov8" title="1">webhooks = append(webhooks, types.WebhookData{
                        Name:                    webhook.Name,
                        ClientConfig:            clientConfig,
                        Rules:                   rules,
                        FailurePolicy:           string(*webhook.FailurePolicy),
                        MatchPolicy:             string(*webhook.MatchPolicy),
                        NamespaceSelector:       namespaceSelector,
                        ObjectSelector:          objectSelector,
                        SideEffects:             string(*webhook.SideEffects),
                        TimeoutSeconds:          *webhook.TimeoutSeconds,
                        AdmissionReviewVersions: webhook.AdmissionReviewVersions,
                })</span>
        }

        <span class="cov8" title="1">createdByKind, createdByName := utils.GetOwnerReferenceInfo(vwc)

        // Create data structure
        data := types.ValidatingWebhookConfigurationData{
                CreatedTimestamp: utils.ExtractCreationTimestamp(vwc),
                Labels:           utils.ExtractLabels(vwc),
                Annotations:      utils.ExtractAnnotations(vwc),
                Webhooks:         webhooks,
                CreatedByKind:    createdByKind,
                CreatedByName:    createdByName,
        }

        return utils.CreateLogEntry("validatingwebhookconfiguration", utils.ExtractName(vwc), utils.ExtractNamespace(vwc), data)</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package resources

import (
        "context"
        "time"

        storagev1 "k8s.io/api/storage/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"

        "github.com/matucker-msft/kube-state-logs/pkg/interfaces"
        "github.com/matucker-msft/kube-state-logs/pkg/types"
        "github.com/matucker-msft/kube-state-logs/pkg/utils"
)

// VolumeAttachmentHandler handles collection of volumeattachment metrics
type VolumeAttachmentHandler struct {
        utils.BaseHandler
}

// NewVolumeAttachmentHandler creates a new VolumeAttachmentHandler
func NewVolumeAttachmentHandler(client kubernetes.Interface) *VolumeAttachmentHandler <span class="cov8" title="1">{
        return &amp;VolumeAttachmentHandler{
                BaseHandler: utils.NewBaseHandler(client),
        }
}</span>

// SetupInformer sets up the volumeattachment informer
func (h *VolumeAttachmentHandler) SetupInformer(factory informers.SharedInformerFactory, logger interfaces.Logger, resyncPeriod time.Duration) error <span class="cov0" title="0">{
        // Create volumeattachment informer
        informer := factory.Storage().V1().VolumeAttachments().Informer()
        h.SetupBaseInformer(informer, logger)
        return nil
}</span>

// Collect gathers volumeattachment metrics from the cluster (uses cache)
func (h *VolumeAttachmentHandler) Collect(ctx context.Context, namespaces []string) ([]types.LogEntry, error) <span class="cov8" title="1">{
        var entries []types.LogEntry

        // Get all volumeattachments from the cache
        vaList := utils.SafeGetStoreList(h.GetInformer())

        for _, obj := range vaList </span><span class="cov8" title="1">{
                va, ok := obj.(*storagev1.VolumeAttachment)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">entry := h.createLogEntry(va)
                entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// createLogEntry creates a LogEntry from a volumeattachment
func (h *VolumeAttachmentHandler) createLogEntry(va *storagev1.VolumeAttachment) types.LogEntry <span class="cov8" title="1">{
        // Get attachment metadata
        attachmentMetadata := make(map[string]string)
        if va.Status.AttachmentMetadata != nil </span><span class="cov8" title="1">{
                for key, value := range va.Status.AttachmentMetadata </span><span class="cov8" title="1">{
                        attachmentMetadata[key] = value
                }</span>
        }

        // Get volume name
        <span class="cov8" title="1">volumeName := ""
        if va.Spec.Source.PersistentVolumeName != nil </span><span class="cov8" title="1">{
                volumeName = *va.Spec.Source.PersistentVolumeName
        }</span>

        <span class="cov8" title="1">createdByKind, createdByName := utils.GetOwnerReferenceInfo(va)

        // Create data structure
        data := types.VolumeAttachmentData{
                CreatedTimestamp:   utils.ExtractCreationTimestamp(va),
                Labels:             utils.ExtractLabels(va),
                Annotations:        utils.ExtractAnnotations(va),
                Attacher:           va.Spec.Attacher,
                VolumeName:         volumeName,
                NodeName:           va.Spec.NodeName,
                Attached:           va.Status.Attached,
                AttachmentMetadata: attachmentMetadata,
                CreatedByKind:      createdByKind,
                CreatedByName:      createdByName,
        }

        return utils.CreateLogEntry("volumeattachment", utils.ExtractName(va), utils.ExtractNamespace(va), data)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
